# 自动更新功能设计方案

**文档版本**: v1.0  
**创建日期**: 2025年10月27日  
**状态**: 📋 待实施（已搁置）  
**预计工作量**: 2个工作日（11-16小时）

---

## 📋 需求概述

### 功能目标

1. **配置同步**: 程序启动时从服务器读取最新配置
2. **手动更新**: 设置菜单添加"检查更新"按钮
3. **自动检测**: 程序启动时自动检测版本并提示更新
4. **跳过版本**: 用户可选择跳过某个版本，直到下一个版本发布

### 服务器路径

```
\\10.102.2.7\文件服务器\建筑结构所\接口文件\
```

---

## 🏗️ 技术架构设计

### 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                      客户端程序                              │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  base.py (主程序)                                      │  │
│  │  ├─ 启动时检查更新 (_check_update_on_startup)         │  │
│  │  ├─ 手动检查更新 (_manual_check_update)               │  │
│  │  └─ 执行更新 (_do_update)                             │  │
│  └───────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  version_manager.py (版本管理器)                       │  │
│  │  ├─ check_update() - 检查更新                         │  │
│  │  ├─ download_update() - 下载更新                      │  │
│  │  ├─ apply_update() - 应用更新                         │  │
│  │  ├─ skip_version() - 跳过版本                         │  │
│  │  └─ sync_config_from_server() - 同步配置              │  │
│  └───────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  update_dialog.py (更新对话框)                         │  │
│  │  ├─ UpdateDialog - 更新提示对话框                     │  │
│  │  └─ DownloadProgressDialog - 下载进度对话框           │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                          ↕ 网络访问
┌─────────────────────────────────────────────────────────────┐
│              服务器 (10.102.2.7)                             │
│  \\10.102.2.7\文件服务器\建筑结构所\接口文件\                │
│  ├─ version.json          # 版本信息文件                    │
│  ├─ config.json           # 共享配置文件                    │
│  ├─ 姓名角色表.xlsx       # 角色表                          │
│  ├─ 接口筛选_v1.2.0.exe   # 最新版本程序                    │
│  └─ changelog.txt         # 更新日志（可选）                │
└─────────────────────────────────────────────────────────────┘
```

---

## 📁 文件结构设计

### 服务器端文件

#### 1. version.json（版本信息文件）

```json
{
  "version": "1.2.0",
  "release_date": "2025-10-27",
  "exe_filename": "接口筛选_v1.2.0.exe",
  "md5_hash": "a1b2c3d4e5f6...",
  "changelog": "修复了勾选功能bug\n新增了缓存功能\n优化了Excel读取性能",
  "force_update": false,
  "min_compatible_version": "1.0.0",
  "file_size_mb": 45.6
}
```

**字段说明**：
- `version`: 版本号（语义化版本，如 1.2.0）
- `release_date`: 发布日期
- `exe_filename`: exe文件名（服务器上的文件名）
- `md5_hash`: MD5校验和（确保文件完整性）
- `changelog`: 更新日志（支持多行，用\n分隔）
- `force_update`: 是否强制更新（true时不允许跳过）
- `min_compatible_version`: 最低兼容版本
- `file_size_mb`: 文件大小（用于显示下载进度）

---

#### 2. config.json（共享配置文件）

```json
{
  "shared_settings": {
    "server_role_table_path": "\\\\10.102.2.7\\文件服务器\\建筑结构所\\接口文件\\姓名角色表.xlsx",
    "default_folder_hint": "请选择包含Excel文件的文件夹"
  },
  "update_settings": {
    "enable_auto_check": true,
    "check_interval_hours": 24
  }
}
```

**注意**：客户端只读取 `shared_settings` 部分，不覆盖用户个人配置。

---

### 客户端文件

#### 1. config.json（本地配置文件 - 新增字段）

```json
{
  "folder_path": "D:/Programs/筛选程序/简易测试文件",
  "auto_startup": false,
  "minimize_to_tray": true,
  "dont_ask_again": false,
  "user_name": "张三",
  
  // ===== 新增字段 =====
  "current_version": "1.1.0",
  "skipped_versions": ["1.1.5", "1.1.8"],
  "last_check_time": "2025-10-27 10:30:00",
  "auto_check_update": true
}
```

**新增字段说明**：
- `current_version`: 当前程序版本（从代码硬编码读取，用于比对）
- `skipped_versions`: 用户选择跳过的版本列表
- `last_check_time`: 最后一次检查更新的时间
- `auto_check_update`: 是否启用自动检查更新

---

## 🔄 核心流程设计

### 流程1：程序启动时自动检查更新

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 程序启动 (ExcelProcessorApp.__init__)                    │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 初始化 VersionManager                                     │
│    - 读取本地 current_version                                │
│    - 读取 skipped_versions                                   │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. 同步服务器配置 (sync_config_from_server)                 │
│    - 读取服务器 config.json 的 shared_settings               │
│    - 更新本地姓名角色表路径等共享配置                        │
│    - 失败不阻塞，记录日志                                    │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 延迟检查更新（避免阻塞界面）                              │
│    - 普通模式: self.root.after(500ms, _check_update)        │
│    - 自动模式: 立即检查但不显示提示                          │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. 后台线程检查更新 (threading.Thread)                      │
│    ├─ 连接服务器（超时3秒）                                  │
│    ├─ 读取 version.json                                      │
│    ├─ 比较版本号                                             │
│    └─ 返回结果到主线程                                       │
└─────────────────────────────────────────────────────────────┘
                          ↓
         ┌────────────────┴────────────────┐
         ↓                                  ↓
┌──────────────────┐            ┌──────────────────┐
│ 服务器版本 > 本地 │            │ 服务器版本 <= 本地│
└──────────────────┘            └──────────────────┘
         ↓                                  ↓
         ↓                        ┌──────────────────┐
         ↓                        │ 继续运行，不提示  │
         ↓                        └──────────────────┘
         ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. 检查是否跳过此版本                                        │
│    - 如果 version in skipped_versions                        │
│      → 跳过提示，继续运行                                    │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 7. 显示更新对话框 (UpdateDialog)                            │
│    ┌───────────────────────────────────────────────────┐    │
│    │ 检测到新版本                                       │    │
│    │                                                   │    │
│    │ 当前版本: v1.1.0                                  │    │
│    │ 最新版本: v1.2.0                                  │    │
│    │ 发布日期: 2025-10-27                              │    │
│    │                                                   │    │
│    │ 更新内容:                                         │    │
│    │ • 修复了勾选功能bug                               │    │
│    │ • 新增了缓存功能                                  │    │
│    │ • 优化了Excel读取性能                             │    │
│    │                                                   │    │
│    │ [ ] 不再提醒此版本                                │    │
│    │                                                   │    │
│    │ [立即更新] [跳过此版本] [稍后提醒]                 │    │
│    └───────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
                          ↓
         ┌────────────────┼────────────────┐
         ↓                ↓                ↓
   ┌─────────┐      ┌─────────┐     ┌─────────┐
   │立即更新  │      │跳过此版本│     │稍后提醒  │
   └─────────┘      └─────────┘     └─────────┘
         ↓                ↓                ↓
  执行更新流程    添加到skipped_   继续运行
  (见流程3)        versions
```

---

### 流程2：手动检查更新

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 用户点击"检查更新"按钮                                     │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 显示"检查中"提示框                                         │
│    ┌───────────────────────────────────────────────────┐    │
│    │ 检查更新                                           │    │
│    │                                                   │    │
│    │        正在检查更新...                             │    │
│    │        [进度动画]                                 │    │
│    └───────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. 后台线程检查 (threading.Thread)                          │
│    - 连接服务器（超时5秒，比自动检查更长）                    │
│    - 读取 version.json                                       │
│    - 比较版本号                                              │
└─────────────────────────────────────────────────────────────┘
                          ↓
         ┌────────────────┴────────────────┐
         ↓                                  ↓
┌──────────────────┐            ┌──────────────────┐
│ 连接成功          │            │ 连接失败          │
└──────────────────┘            └──────────────────┘
         ↓                                  ↓
         ↓                        ┌──────────────────┐
         ↓                        │ 提示"无法连接到   │
         ↓                        │ 服务器"           │
         ↓                        └──────────────────┘
         ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 关闭"检查中"提示框                                         │
└─────────────────────────────────────────────────────────────┘
                          ↓
         ┌────────────────┴────────────────┐
         ↓                                  ↓
┌──────────────────┐            ┌──────────────────┐
│ 有新版本          │            │ 已是最新版本      │
└──────────────────┘            └──────────────────┘
         ↓                                  ↓
  显示更新对话框              ┌──────────────────┐
  (同流程1的步骤7)            │ 提示"当前已是最新 │
                              │ 版本 v1.1.0"      │
                              └──────────────────┘
```

---

### 流程3：下载并应用更新

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 用户选择"立即更新"                                         │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 显示下载进度对话框 (DownloadProgressDialog)              │
│    ┌───────────────────────────────────────────────────┐    │
│    │ 下载更新                                           │    │
│    │                                                   │    │
│    │ 正在下载: 接口筛选_v1.2.0.exe                      │    │
│    │                                                   │    │
│    │ [█████████████░░░░░░░] 65%                        │    │
│    │                                                   │    │
│    │ 已下载: 30.5 MB / 45.6 MB                         │    │
│    │ 速度: 5.2 MB/s                                    │    │
│    │ 剩余时间: 约 3 秒                                  │    │
│    │                                                   │    │
│    │              [取消下载]                            │    │
│    └───────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. 下载文件到临时位置                                         │
│    源: \\10.102.2.7\...\接口筛选_v1.2.0.exe                  │
│    目标: ./接口筛选_v1.2.0.exe.tmp                            │
│    - 分块下载（1MB per chunk）                                │
│    - 实时更新进度回调                                         │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 验证文件完整性                                             │
│    - 计算下载文件的MD5                                        │
│    - 与 version.json 中的 md5_hash 比对                      │
│    - 不一致 → 提示错误，删除临时文件                          │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. 备份当前版本                                               │
│    - 将 接口筛选.exe 重命名为 接口筛选.exe.backup             │
│    - 保留备份以防更新失败                                     │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. 重命名新版本                                               │
│    - 将 接口筛选_v1.2.0.exe.tmp → 接口筛选_v1.2.0.exe         │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 7. 创建更新脚本 (update.bat)                                 │
│    @echo off                                                 │
│    echo 正在应用更新...                                       │
│    timeout /t 2 /nobreak >nul                                │
│    taskkill /f /im 接口筛选.exe                              │
│    if exist "接口筛选_v1.2.0.exe" (                           │
│        move /y "接口筛选_v1.2.0.exe" "接口筛选.exe"           │
│        start "" "接口筛选.exe" --auto                         │
│        del "接口筛选.exe.backup"                              │
│    ) else (                                                  │
│        echo 更新失败，恢复备份...                             │
│        move /y "接口筛选.exe.backup" "接口筛选.exe"           │
│        start "" "接口筛选.exe"                                │
│    )                                                         │
│    del update.bat                                            │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 8. 询问用户是否立即重启                                       │
│    ┌───────────────────────────────────────────────────┐    │
│    │ 更新成功                                           │    │
│    │                                                   │    │
│    │ 版本 v1.2.0 下载完成！                            │    │
│    │                                                   │    │
│    │ 是否立即重启应用更新？                             │    │
│    │ （选择"否"将在下次启动时生效）                     │    │
│    │                                                   │    │
│    │         [是(Y)]    [否(N)]                         │    │
│    └───────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
                          ↓
         ┌────────────────┴────────────────┐
         ↓                                  ↓
    ┌─────────┐                      ┌─────────┐
    │ 选择"是" │                      │ 选择"否" │
    └─────────┘                      └─────────┘
         ↓                                  ↓
┌──────────────────┐            ┌──────────────────┐
│ 9a. 立即重启      │            │ 9b. 稍后重启      │
│ - 启动update.bat  │            │ - 新版本文件已就位│
│ - 退出当前程序    │            │ - 下次启动时生效  │
└──────────────────┘            └──────────────────┘
```

---

## 💻 核心代码设计

### 文件1: version_manager.py

```python
# -*- coding: utf-8 -*-
"""
版本管理器模块

功能：
1. 版本检测和比较
2. 配置同步
3. 文件下载
4. 更新应用
"""

import os
import sys
import json
import hashlib
import threading
import shutil
from typing import Tuple, Optional, Dict, List, Callable


class VersionManager:
    """版本管理器"""
    
    # 服务器配置
    SERVER_PATH = r"\\10.102.2.7\文件服务器\建筑结构所\接口文件"
    
    # 当前版本（硬编码，每次发布时更新）
    CURRENT_VERSION = "1.1.0"
    
    def __init__(self, config_file: str = "config.json"):
        """
        初始化版本管理器
        
        参数:
            config_file: 本地配置文件路径
        """
        self.config_file = config_file
        self.skipped_versions: List[str] = []
        self.last_check_time: Optional[str] = None
        self.auto_check_update: bool = True
        
        # 加载本地配置
        self._load_config()
    
    def _load_config(self):
        """加载本地配置"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    self.skipped_versions = config.get('skipped_versions', [])
                    self.last_check_time = config.get('last_check_time')
                    self.auto_check_update = config.get('auto_check_update', True)
        except Exception as e:
            print(f"加载配置失败: {e}")
    
    def _save_config(self):
        """保存本地配置"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
            else:
                config = {}
            
            config['skipped_versions'] = self.skipped_versions
            config['last_check_time'] = self.last_check_time
            config['auto_check_update'] = self.auto_check_update
            config['current_version'] = self.CURRENT_VERSION
            
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"保存配置失败: {e}")
    
    @staticmethod
    def compare_version(v1: str, v2: str) -> int:
        """
        比较版本号
        
        参数:
            v1: 版本号1 (如 "1.2.0")
            v2: 版本号2 (如 "1.1.0")
        
        返回:
            1: v1 > v2
            0: v1 == v2
           -1: v1 < v2
        """
        try:
            parts1 = [int(x) for x in v1.split('.')]
            parts2 = [int(x) for x in v2.split('.')]
            
            # 补齐长度
            max_len = max(len(parts1), len(parts2))
            parts1.extend([0] * (max_len - len(parts1)))
            parts2.extend([0] * (max_len - len(parts2)))
            
            for p1, p2 in zip(parts1, parts2):
                if p1 > p2:
                    return 1
                elif p1 < p2:
                    return -1
            return 0
        except Exception as e:
            print(f"版本比较失败: {e}")
            return 0
    
    def check_server_accessible(self, timeout: int = 3) -> bool:
        """
        检查服务器是否可访问
        
        参数:
            timeout: 超时时间（秒）
        
        返回:
            True: 可访问
            False: 不可访问
        """
        result = [False]
        
        def check():
            try:
                version_file = os.path.join(self.SERVER_PATH, "version.json")
                result[0] = os.path.exists(version_file)
            except Exception as e:
                print(f"检查服务器可访问性失败: {e}")
                result[0] = False
        
        thread = threading.Thread(target=check, daemon=True)
        thread.start()
        thread.join(timeout)
        
        return result[0]
    
    def get_server_version_info(self) -> Optional[Dict]:
        """
        从服务器获取版本信息
        
        返回:
            版本信息字典，失败返回None
        """
        try:
            version_file = os.path.join(self.SERVER_PATH, "version.json")
            
            if not os.path.exists(version_file):
                print(f"服务器版本文件不存在: {version_file}")
                return None
            
            with open(version_file, 'r', encoding='utf-8') as f:
                version_info = json.load(f)
            
            # 验证必要字段
            required_fields = ['version', 'exe_filename', 'md5_hash']
            for field in required_fields:
                if field not in version_info:
                    print(f"版本信息缺少必要字段: {field}")
                    return None
            
            return version_info
        except Exception as e:
            print(f"读取服务器版本信息失败: {e}")
            return None
    
    def check_update(self, silent: bool = False) -> Tuple[bool, Optional[Dict]]:
        """
        检查是否有更新
        
        参数:
            silent: 是否静默检查（不记录日志）
        
        返回:
            (has_update, version_info)
            - has_update: 是否有更新
            - version_info: 版本信息（有更新时）
        """
        try:
            # 检查服务器可访问性
            if not self.check_server_accessible():
                if not silent:
                    print("无法连接到服务器")
                return False, None
            
            # 获取服务器版本信息
            server_version_info = self.get_server_version_info()
            if not server_version_info:
                return False, None
            
            server_version = server_version_info['version']
            
            # 比较版本
            compare_result = self.compare_version(server_version, self.CURRENT_VERSION)
            
            if compare_result > 0:
                # 服务器版本更新
                if not silent:
                    print(f"检测到新版本: {server_version} (当前: {self.CURRENT_VERSION})")
                return True, server_version_info
            else:
                if not silent:
                    print(f"当前已是最新版本: {self.CURRENT_VERSION}")
                return False, None
        
        except Exception as e:
            print(f"检查更新失败: {e}")
            return False, None
    
    def download_update(self, 
                       version_info: Dict, 
                       progress_callback: Optional[Callable[[int, int], None]] = None) -> str:
        """
        下载更新文件
        
        参数:
            version_info: 版本信息
            progress_callback: 进度回调函数 (current_bytes, total_bytes)
        
        返回:
            下载文件的本地路径
        
        异常:
            Exception: 下载失败
        """
        try:
            # 源文件路径
            exe_filename = version_info['exe_filename']
            source_path = os.path.join(self.SERVER_PATH, exe_filename)
            
            if not os.path.exists(source_path):
                raise FileNotFoundError(f"服务器文件不存在: {source_path}")
            
            # 目标临时文件路径
            dest_path = os.path.join(os.getcwd(), f"{exe_filename}.tmp")
            
            # 获取文件大小
            file_size = os.path.getsize(source_path)
            
            # 下载文件
            chunk_size = 1024 * 1024  # 1MB
            copied = 0
            
            with open(source_path, 'rb') as src, open(dest_path, 'wb') as dst:
                while True:
                    chunk = src.read(chunk_size)
                    if not chunk:
                        break
                    dst.write(chunk)
                    copied += len(chunk)
                    
                    # 回调进度
                    if progress_callback:
                        progress_callback(copied, file_size)
            
            # 验证MD5
            expected_md5 = version_info['md5_hash']
            actual_md5 = self._calculate_md5(dest_path)
            
            if actual_md5 != expected_md5:
                os.remove(dest_path)
                raise ValueError(f"文件校验失败: MD5不匹配")
            
            # 重命名为正式文件名
            final_path = dest_path.replace('.tmp', '')
            if os.path.exists(final_path):
                os.remove(final_path)
            os.rename(dest_path, final_path)
            
            print(f"下载完成: {final_path}")
            return final_path
        
        except Exception as e:
            print(f"下载更新失败: {e}")
            raise
    
    @staticmethod
    def _calculate_md5(file_path: str) -> str:
        """计算文件MD5"""
        md5 = hashlib.md5()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                md5.update(chunk)
        return md5.hexdigest()
    
    def apply_update(self, new_exe_path: str):
        """
        应用更新（创建bat脚本并启动）
        
        参数:
            new_exe_path: 新版本exe的路径
        """
        try:
            current_exe = sys.executable if getattr(sys, 'frozen', False) else "接口筛选.exe"
            current_exe_backup = f"{current_exe}.backup"
            
            # 创建更新脚本
            bat_content = f"""@echo off
echo 正在应用更新...
timeout /t 2 /nobreak >nul

taskkill /f /im "{os.path.basename(current_exe)}" 2>nul

if exist "{new_exe_path}" (
    echo 备份当前版本...
    if exist "{current_exe}" (
        move /y "{current_exe}" "{current_exe_backup}"
    )
    
    echo 安装新版本...
    move /y "{new_exe_path}" "{current_exe}"
    
    if exist "{current_exe}" (
        echo 更新成功！启动新版本...
        start "" "{current_exe}" --auto
        del "{current_exe_backup}" 2>nul
    ) else (
        echo 更新失败，恢复备份...
        move /y "{current_exe_backup}" "{current_exe}"
        start "" "{current_exe}"
    )
) else (
    echo 新版本文件不存在，取消更新
    if exist "{current_exe_backup}" (
        move /y "{current_exe_backup}" "{current_exe}"
    )
    start "" "{current_exe}"
)

del update.bat
"""
            
            bat_path = "update.bat"
            with open(bat_path, 'w', encoding='gbk') as f:
                f.write(bat_content)
            
            # 启动bat脚本
            os.startfile(bat_path)
            print("更新脚本已启动")
        
        except Exception as e:
            print(f"应用更新失败: {e}")
            raise
    
    def skip_version(self, version: str):
        """
        跳过指定版本
        
        参数:
            version: 要跳过的版本号
        """
        if version not in self.skipped_versions:
            self.skipped_versions.append(version)
            self._save_config()
            print(f"已跳过版本: {version}")
    
    def sync_config_from_server(self) -> bool:
        """
        从服务器同步配置
        
        返回:
            True: 同步成功
            False: 同步失败
        """
        try:
            config_file = os.path.join(self.SERVER_PATH, "config.json")
            
            if not os.path.exists(config_file):
                print("服务器配置文件不存在")
                return False
            
            with open(config_file, 'r', encoding='utf-8') as f:
                server_config = json.load(f)
            
            # 只同步shared_settings部分
            shared_settings = server_config.get('shared_settings', {})
            
            if shared_settings:
                # 更新本地配置（不覆盖用户个人设置）
                if os.path.exists(self.config_file):
                    with open(self.config_file, 'r', encoding='utf-8') as f:
                        local_config = json.load(f)
                else:
                    local_config = {}
                
                # 合并配置
                for key, value in shared_settings.items():
                    local_config[key] = value
                
                with open(self.config_file, 'w', encoding='utf-8') as f:
                    json.dump(local_config, f, indent=2, ensure_ascii=False)
                
                print("配置同步成功")
                return True
            
            return False
        
        except Exception as e:
            print(f"同步配置失败: {e}")
            return False
```

---

### 文件2: update_dialog.py

```python
# -*- coding: utf-8 -*-
"""
更新对话框模块
"""

import tkinter as tk
from tkinter import ttk
from typing import Optional, Dict


class UpdateDialog:
    """更新提示对话框"""
    
    def __init__(self, parent, version_info: Dict):
        """
        初始化更新对话框
        
        参数:
            parent: 父窗口
            version_info: 版本信息
        """
        self.parent = parent
        self.version_info = version_info
        self.result = "later"  # update / skip / later
        self.skip_this_version = False
        
        self.dialog = tk.Toplevel(parent)
        self.dialog.title("检测到新版本")
        self.dialog.geometry("500x400")
        self.dialog.transient(parent)
        self.dialog.grab_set()
        self.dialog.resizable(False, False)
        
        self._create_widgets()
        
        # 居中显示
        self._center_window()
    
    def _center_window(self):
        """窗口居中"""
        self.dialog.update_idletasks()
        x = self.parent.winfo_rootx() + (self.parent.winfo_width() // 2) - (self.dialog.winfo_width() // 2)
        y = self.parent.winfo_rooty() + (self.parent.winfo_height() // 2) - (self.dialog.winfo_height() // 2)
        self.dialog.geometry(f"+{x}+{y}")
    
    def _create_widgets(self):
        """创建界面组件"""
        # 主框架
        main_frame = ttk.Frame(self.dialog, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # 标题
        title_label = ttk.Label(main_frame, 
                                text="🎉 检测到新版本！", 
                                font=("", 14, "bold"))
        title_label.pack(pady=(0, 15))
        
        # 版本信息框架
        info_frame = ttk.Frame(main_frame)
        info_frame.pack(fill=tk.X, pady=(0, 15))
        
        from version_manager import VersionManager
        current_version = VersionManager.CURRENT_VERSION
        new_version = self.version_info.get('version', 'Unknown')
        release_date = self.version_info.get('release_date', 'Unknown')
        
        ttk.Label(info_frame, text=f"当前版本: v{current_version}").pack(anchor=tk.W)
        ttk.Label(info_frame, text=f"最新版本: v{new_version}", 
                 font=("", 10, "bold"), foreground="green").pack(anchor=tk.W)
        ttk.Label(info_frame, text=f"发布日期: {release_date}").pack(anchor=tk.W)
        
        # 更新内容
        changelog_frame = ttk.LabelFrame(main_frame, text="更新内容", padding="10")
        changelog_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 15))
        
        changelog_text = tk.Text(changelog_frame, height=10, wrap=tk.WORD, 
                                 relief=tk.FLAT, bg="#f0f0f0")
        changelog_text.pack(fill=tk.BOTH, expand=True)
        
        changelog = self.version_info.get('changelog', '暂无更新说明')
        changelog_text.insert('1.0', changelog)
        changelog_text.config(state=tk.DISABLED)
        
        # 跳过版本复选框
        self.skip_var = tk.BooleanVar(value=False)
        skip_check = ttk.Checkbutton(main_frame, 
                                     text="不再提醒此版本", 
                                     variable=self.skip_var)
        skip_check.pack(anchor=tk.W, pady=(0, 15))
        
        # 按钮框架
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X)
        
        ttk.Button(button_frame, text="立即更新", 
                  command=self._on_update, 
                  width=12).pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(button_frame, text="跳过此版本", 
                  command=self._on_skip, 
                  width=12).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(button_frame, text="稍后提醒", 
                  command=self._on_later, 
                  width=12).pack(side=tk.LEFT, padx=(5, 0))
    
    def _on_update(self):
        """点击"立即更新"按钮"""
        self.result = "update"
        self.skip_this_version = self.skip_var.get()
        self.dialog.destroy()
    
    def _on_skip(self):
        """点击"跳过此版本"按钮"""
        self.result = "skip"
        self.skip_this_version = True  # 强制跳过
        self.dialog.destroy()
    
    def _on_later(self):
        """点击"稍后提醒"按钮"""
        self.result = "later"
        self.skip_this_version = self.skip_var.get()
        self.dialog.destroy()
    
    def show(self) -> str:
        """
        显示对话框并等待用户选择
        
        返回:
            "update" / "skip" / "later"
        """
        self.dialog.wait_window()
        
        # 如果勾选了"不再提醒"，返回skip
        if self.skip_this_version and self.result == "later":
            self.result = "skip"
        
        return self.result


class DownloadProgressDialog:
    """下载进度对话框"""
    
    def __init__(self, parent):
        """
        初始化下载进度对话框
        
        参数:
            parent: 父窗口
        """
        self.parent = parent
        self.cancelled = False
        
        self.dialog = tk.Toplevel(parent)
        self.dialog.title("下载更新")
        self.dialog.geometry("450x200")
        self.dialog.transient(parent)
        self.dialog.grab_set()
        self.dialog.resizable(False, False)
        
        # 禁止关闭窗口
        self.dialog.protocol("WM_DELETE_WINDOW", self._on_cancel)
        
        self._create_widgets()
        self._center_window()
    
    def _center_window(self):
        """窗口居中"""
        self.dialog.update_idletasks()
        x = self.parent.winfo_rootx() + (self.parent.winfo_width() // 2) - (self.dialog.winfo_width() // 2)
        y = self.parent.winfo_rooty() + (self.parent.winfo_height() // 2) - (self.dialog.winfo_height() // 2)
        self.dialog.geometry(f"+{x}+{y}")
    
    def _create_widgets(self):
        """创建界面组件"""
        main_frame = ttk.Frame(self.dialog, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # 文件名标签
        self.filename_label = ttk.Label(main_frame, text="正在下载...", 
                                       font=("", 10, "bold"))
        self.filename_label.pack(pady=(0, 15))
        
        # 进度条
        self.progress_var = tk.DoubleVar(value=0)
        self.progress_bar = ttk.Progressbar(main_frame, 
                                           variable=self.progress_var, 
                                           maximum=100, 
                                           length=400)
        self.progress_bar.pack(pady=(0, 10))
        
        # 进度信息
        self.info_label = ttk.Label(main_frame, text="0 MB / 0 MB")
        self.info_label.pack()
        
        self.speed_label = ttk.Label(main_frame, text="速度: 0 MB/s")
        self.speed_label.pack()
        
        self.eta_label = ttk.Label(main_frame, text="剩余时间: 计算中...")
        self.eta_label.pack()
        
        # 取消按钮
        ttk.Button(main_frame, text="取消下载", 
                  command=self._on_cancel).pack(pady=(15, 0))
        
        self.last_update_time = None
        self.last_bytes = 0
    
    def update_progress(self, current_bytes: int, total_bytes: int):
        """
        更新进度
        
        参数:
            current_bytes: 已下载字节数
            total_bytes: 总字节数
        """
        import time
        
        # 更新进度条
        progress = (current_bytes / total_bytes) * 100 if total_bytes > 0 else 0
        self.progress_var.set(progress)
        
        # 更新文件大小信息
        current_mb = current_bytes / (1024 * 1024)
        total_mb = total_bytes / (1024 * 1024)
        self.info_label.config(text=f"{current_mb:.1f} MB / {total_mb:.1f} MB")
        
        # 计算速度
        current_time = time.time()
        if self.last_update_time:
            time_diff = current_time - self.last_update_time
            if time_diff > 0:
                bytes_diff = current_bytes - self.last_bytes
                speed_mbps = (bytes_diff / time_diff) / (1024 * 1024)
                self.speed_label.config(text=f"速度: {speed_mbps:.1f} MB/s")
                
                # 计算剩余时间
                if speed_mbps > 0:
                    remaining_bytes = total_bytes - current_bytes
                    eta_seconds = remaining_bytes / (speed_mbps * 1024 * 1024)
                    if eta_seconds < 60:
                        eta_text = f"剩余时间: 约 {int(eta_seconds)} 秒"
                    else:
                        eta_minutes = int(eta_seconds / 60)
                        eta_text = f"剩余时间: 约 {eta_minutes} 分钟"
                    self.eta_label.config(text=eta_text)
        
        self.last_update_time = current_time
        self.last_bytes = current_bytes
        
        # 更新界面
        self.dialog.update()
    
    def _on_cancel(self):
        """取消下载"""
        self.cancelled = True
        self.dialog.destroy()
    
    def close(self):
        """关闭对话框"""
        try:
            self.dialog.destroy()
        except:
            pass
```

---

### 文件3: base.py（修改部分）

```python
# 在 ExcelProcessorApp.__init__ 中添加

def __init__(self, auto_mode: bool = False):
    self.auto_mode = auto_mode
    
    # ... 现有初始化代码 ...
    
    # ===== 新增：版本管理器 =====
    from version_manager import VersionManager
    self.version_manager = VersionManager()
    
    # ===== 新增：启动时同步配置 =====
    try:
        self.version_manager.sync_config_from_server()
    except Exception as e:
        print(f"同步服务器配置失败: {e}")
    
    # ===== 新增：启动时检查更新 =====
    if not auto_mode:
        # 普通启动：延迟500ms后检查（避免阻塞界面）
        self.root.after(500, lambda: threading.Thread(
            target=self._check_update_on_startup, 
            daemon=True
        ).start())
    else:
        # 自动模式：在自动运行前检查
        threading.Thread(
            target=self._check_update_on_startup, 
            daemon=True
        ).start()


# ===== 新增方法 =====

def _check_update_on_startup(self):
    """启动时检查更新"""
    try:
        # 检查更新
        has_update, version_info = self.version_manager.check_update(silent=True)
        
        if not has_update:
            return
        
        # 检查是否跳过此版本
        if version_info["version"] in self.version_manager.skipped_versions:
            print(f"已跳过版本 {version_info['version']}")
            return
        
        # 自动模式下的特殊处理
        if self.auto_mode:
            # 如果是强制更新，则显示提示
            if version_info.get("force_update", False):
                # 在主线程中显示对话框
                self.root.after(0, lambda: self._show_update_dialog(version_info))
            else:
                # 非强制更新，记录日志并继续
                print(f"检测到新版本 {version_info['version']}，自动模式下已跳过")
            return
        
        # 普通模式：在主线程中显示更新对话框
        self.root.after(0, lambda: self._show_update_dialog(version_info))
    
    except Exception as e:
        print(f"检查更新失败: {e}")


def _show_update_dialog(self, version_info):
    """显示更新对话框"""
    try:
        from update_dialog import UpdateDialog
        dialog = UpdateDialog(self.root, version_info)
        choice = dialog.show()
        
        if choice == "update":
            self._do_update(version_info)
        elif choice == "skip":
            self.version_manager.skip_version(version_info["version"])
    except Exception as e:
        print(f"显示更新对话框失败: {e}")


def _manual_check_update(self):
    """手动检查更新"""
    # 显示"检查中"提示
    checking_dialog = self.show_waiting_dialog("检查更新", "正在检查更新...")
    
    def check_in_thread():
        try:
            has_update, version_info = self.version_manager.check_update(silent=False)
            
            # 在主线程中关闭"检查中"提示
            if checking_dialog:
                self.root.after(0, lambda: checking_dialog[0].destroy() if checking_dialog[0].winfo_exists() else None)
            
            if has_update:
                # 在主线程中显示更新对话框
                self.root.after(0, lambda: self._show_update_dialog(version_info))
            else:
                # 在主线程中显示提示
                self.root.after(0, lambda: messagebox.showinfo("检查更新", 
                    f"当前已是最新版本 v{self.version_manager.CURRENT_VERSION}"))
        except Exception as e:
            if checking_dialog:
                self.root.after(0, lambda: checking_dialog[0].destroy() if checking_dialog[0].winfo_exists() else None)
            
            self.root.after(0, lambda: messagebox.showerror("检查更新失败", 
                f"无法连接到服务器或检查更新失败：\n{e}"))
    
    # 在后台线程检查
    threading.Thread(target=check_in_thread, daemon=True).start()


def _do_update(self, version_info):
    """执行更新"""
    try:
        from update_dialog import DownloadProgressDialog
        
        # 显示下载进度对话框
        progress_dialog = DownloadProgressDialog(self.root)
        
        def progress_callback(current, total):
            self.root.after(0, lambda: progress_dialog.update_progress(current, total))
        
        # 在后台线程下载
        def download_in_thread():
            try:
                exe_path = self.version_manager.download_update(
                    version_info, 
                    progress_callback=progress_callback
                )
                
                # 在主线程中关闭进度对话框
                self.root.after(0, lambda: progress_dialog.close())
                
                # 在主线程中询问是否重启
                def ask_restart():
                    result = messagebox.askyesno("更新成功", 
                        f"版本 {version_info['version']} 下载完成！\n\n"
                        "是否立即重启应用更新？\n"
                        "（选择"否"将在下次启动时生效）")
                    
                    if result:
                        # 应用更新并退出
                        self.version_manager.apply_update(exe_path)
                        self.root.destroy()
                        sys.exit(0)
                
                self.root.after(0, ask_restart)
            
            except Exception as e:
                self.root.after(0, lambda: progress_dialog.close())
                self.root.after(0, lambda: messagebox.showerror("更新失败", 
                    f"下载或安装更新失败：\n{e}"))
        
        threading.Thread(target=download_in_thread, daemon=True).start()
    
    except Exception as e:
        messagebox.showerror("更新失败", f"更新过程失败：\n{e}")


# ===== 修改 show_settings_menu 方法 =====

def show_settings_menu(self):
    # ... 现有代码 ...
    
    # ===== 新增："检查更新"按钮 =====
    update_button = ttk.Button(frame, text="检查更新", 
                               command=self._manual_check_update, width=14)
    update_button.pack(pady=(5, 0))
    
    # 清除缓存按钮
    cache_button = ttk.Button(frame, text="清除缓存", 
                              command=on_clear_cache, width=14)
    cache_button.pack(pady=(5, 0))
    
    # 关闭按钮
    close_button = ttk.Button(frame, text="确定", 
                              command=settings_menu.destroy, width=14)
    close_button.pack(pady=(5, 0))
```

---

## ⚠️ 重要注意事项

### 1. 服务器路径访问

**问题**: Windows UNC路径访问可能需要网络凭据

**解决方案**:
- 确保服务器共享文件夹对所有用户开放读取权限
- 测试路径：在Windows资源管理器中输入 `\\10.102.2.7\文件服务器\建筑结构所\接口文件\` 确认可访问
- 如需密码，建议配置域账户自动登录

---

### 2. 版本号管理

**硬编码位置**: `version_manager.py` 的 `CURRENT_VERSION`

**发布流程**:
1. 修改 `CURRENT_VERSION = "1.2.0"`
2. 打包程序
3. 计算新exe的MD5
4. 更新服务器的 `version.json`
5. 上传新exe到服务器

---

### 3. 更新失败回滚

**安全机制**:
- 下载前备份当前版本（`.backup`后缀）
- MD5校验失败自动删除临时文件
- `update.bat` 中包含回滚逻辑
- 如果新版本启动失败，手动运行 `.backup` 文件

---

### 4. 自动模式下的更新

**策略**:
- 默认跳过非强制更新
- 强制更新（`force_update: true`）时显示提示
- 不阻塞自动运行流程
- 记录日志供查看

---

### 5. 网络超时处理

**超时设置**:
- 自动检查：3秒超时
- 手动检查：5秒超时
- 文件下载：无超时（显示进度）

**失败处理**:
- 不弹窗报错（自动检查）
- 记录日志
- 不影响程序正常运行

---

### 6. 并发访问

**问题**: 多个用户同时下载同一个文件

**影响**: 服务器带宽可能饱和

**建议**:
- 分批通知用户更新
- 或在 `version.json` 中设置 `release_date`，不同用户在不同天检查更新

---

### 7. 配置同步策略

**当前方案**: 只同步 `shared_settings` 部分

**优点**: 不覆盖用户个人配置

**示例**:
```json
// 服务器 config.json
{
  "shared_settings": {
    "server_role_table_path": "..."
  }
}

// 客户端 config.json（合并后）
{
  "folder_path": "D:/...",  // 用户个人配置，保留
  "user_name": "张三",      // 用户个人配置，保留
  "server_role_table_path": "..."  // 从服务器同步
}
```

---

### 8. 打包配置更新

**excel_processor.spec 需要添加**:
```python
datas=[
    # ... 现有文件 ...
    ('version_manager.py', '.'),
    ('update_dialog.py', '.'),
],

hiddenimports=[
    # ... 现有导入 ...
    'version_manager',
    'update_dialog',
],
```

---

## 🧪 测试场景

### 测试清单

- [ ] **场景1**: 首次启动，服务器有新版本（普通模式）
  - 预期：延迟500ms后显示更新对话框
  
- [ ] **场景2**: 首次启动，服务器有新版本（自动模式）
  - 预期：不显示提示，记录日志，继续自动运行
  
- [ ] **场景3**: 首次启动，服务器无新版本
  - 预期：无提示，正常运行
  
- [ ] **场景4**: 首次启动，服务器不可达
  - 预期：3秒超时，无提示，正常运行
  
- [ ] **场景5**: 手动点击"检查更新"，有新版本
  - 预期：显示更新对话框
  
- [ ] **场景6**: 手动点击"检查更新"，无新版本
  - 预期：提示"当前已是最新版本"
  
- [ ] **场景7**: 手动点击"检查更新"，服务器不可达
  - 预期：5秒后提示"无法连接到服务器"
  
- [ ] **场景8**: 用户选择"跳过此版本"
  - 预期：版本添加到 `skipped_versions`，下次启动不再提示
  
- [ ] **场景9**: 跳过版本后，服务器发布更新版本
  - 预期：再次显示更新提示
  
- [ ] **场景10**: 下载更新，MD5校验失败
  - 预期：提示"文件校验失败"，删除临时文件
  
- [ ] **场景11**: 下载更新，用户中途取消
  - 预期：删除临时文件，继续运行
  
- [ ] **场景12**: 应用更新，立即重启
  - 预期：启动 update.bat，程序退出，新版本启动
  
- [ ] **场景13**: 应用更新，稍后重启
  - 预期：新版本文件就位，下次手动启动时生效
  
- [ ] **场景14**: 配置同步功能
  - 预期：服务器配置合并到本地，不覆盖用户个人设置

---

## 📝 待确认问题

### ❓ 问题1：服务器路径确认

```
\\10.102.2.7\文件服务器\建筑结构所\接口文件\
```

请确认：
- [ ] 路径格式正确
- [ ] 所有客户端都能访问
- [ ] 有读取权限（不需要密码）

---

### ❓ 问题2：版本号格式

建议使用语义化版本：`主版本.次版本.修订号`

示例：
- `1.0.0` - 首个正式版
- `1.1.0` - 新增功能
- `1.1.1` - Bug修复
- `2.0.0` - 重大更新

**是否同意？** [ ] 是 [ ] 否（请说明其他格式）

---

### ❓ 问题3：强制更新策略

是否需要"强制更新"功能？

**场景**: 发现严重bug，必须所有用户立即更新

**行为**: 不允许跳过，只能"更新"或"退出程序"

**是否需要？** [ ] 是 [ ] 否

---

### ❓ 问题4：自动模式下的更新行为

`--auto` 模式启动时，如果检测到更新：

**选项A**（推荐）: 完全跳过，不提示，继续运行  
**选项B**: 记录日志，显示简短通知（不阻塞）  
**选项C**: 暂停自动运行，显示更新提示

**选择哪个？** [ ] A [ ] B [ ] C

---

### ❓ 问题5：配置同步范围

从服务器同步哪些配置？

**选项A**（推荐）: 只同步 `姓名角色表.xlsx` 路径  
**选项B**: 同步 `config.json` 中的指定字段  
**选项C**: 完全同步 `config.json`（可能覆盖用户设置）

**选择哪个？** [ ] A [ ] B [ ] C

---

### ❓ 问题6：更新检查频率

**当前方案**: 每次程序启动时检查

**是否需要**:
- [ ] 定期检查（如每天一次）
- [ ] 手动检查（只通过"检查更新"按钮）
- [ ] 保持当前方案（每次启动检查）

---

## 📊 工作量估算

| 任务 | 工作量 | 说明 |
|------|-------|------|
| version_manager.py | 4-6小时 | 核心逻辑（约300行） |
| update_dialog.py | 2-3小时 | GUI对话框（约200行） |
| 集成到 base.py | 2-3小时 | 5个集成点 |
| 服务器配置准备 | 1小时 | 创建version.json等 |
| 测试和调试 | 3-4小时 | 14个测试场景 |
| 文档和打包配置 | 1小时 | 更新spec文件 |
| **总计** | **13-18小时** | **约2-3个工作日** |

---

## 🎯 实施建议

### 短期方案（1周内）

**优先级**: ⭐⭐⭐⭐⭐

只实现**配置同步**功能：
- 程序启动时从服务器读取 `姓名角色表.xlsx` 路径
- 工作量：2-3小时
- 立即见效

---

### 中期方案（2周内）

**优先级**: ⭐⭐⭐⭐

实现**完整自动更新**功能：
- 版本检测
- 手动更新
- 自动提示
- 跳过版本
- 工作量：2-3个工作日

---

### 长期方案（1月内）

**优先级**: ⭐⭐⭐

增强功能：
- 增量更新（只下载变化的文件）
- 更新日志网页版
- 更新统计和分析
- 工作量：1周

---

## 📚 参考资料

### 技术参考

1. **Windows UNC路径**: `\\server\share\folder`
2. **批处理脚本**: Windows Batch 命令
3. **MD5校验**: `hashlib.md5()`
4. **语义化版本**: https://semver.org/lang/zh-CN/
5. **Tkinter线程安全**: 使用 `root.after(0, callback)` 在主线程更新UI

---

### 类似案例

1. **VSCode**: 自动检测更新，后台下载，重启应用
2. **微信**: 启动时检查更新，提示用户下载
3. **Electron**: 使用 `electron-updater` 实现自动更新

---

## 📅 待办事项

### 开发前

- [ ] 确认服务器路径可访问
- [ ] 确认版本号格式
- [ ] 回答6个待确认问题
- [ ] 准备测试环境

---

### 开发中

- [ ] 创建 version_manager.py
- [ ] 创建 update_dialog.py
- [ ] 修改 base.py
- [ ] 更新 excel_processor.spec
- [ ] 创建服务器端 version.json

---

### 测试

- [ ] 完成14个测试场景
- [ ] 多用户并发测试
- [ ] 网络异常测试
- [ ] 回滚机制测试

---

### 部署

- [ ] 打包新版本
- [ ] 上传到服务器
- [ ] 通知用户更新
- [ ] 监控更新日志

---

## 🔚 总结

本设计方案提供了一个**完整、安全、用户友好**的自动更新解决方案。

**核心优势**：
- ✅ 不阻塞程序启动
- ✅ 支持手动和自动检查
- ✅ 完善的错误处理和回滚
- ✅ 用户可控（跳过版本）
- ✅ 配置同步功能
- ✅ 自动模式友好

**建议**：
1. 先实施**配置同步**功能（工作量小，立即见效）
2. 再实施**完整自动更新**功能（2-3个工作日）
3. 根据实际使用反馈，优化和增强

---

**文档状态**: 📋 设计完成，待确认后实施  
**最后更新**: 2025年10月27日

