# 文件6重复记录问题分析与修复

**报告日期**: 2025-11-10  
**问题严重程度**: 🔴 高（数据逻辑错误）

---

## 📋 问题描述

用户报告了文件6存在严重的逻辑混乱：

### 问题1：回文单号没有写入Excel
- 用户在程序中填写了回文单号
- 但源Excel文件中没有相应数据

### 问题2：历史记录中出现重复接口
- 同一接口号出现两条记录
- 一条显示"请指派"
- 另一条显示"待完成"

### 问题3：主显示窗状态错误
- 接口状态变成"请指派"
- 但实际应该是"待完成"（因为有责任人）

### 问题4：回文单号记录混乱
- 新的"请指派"记录有回文单号
- 旧的"待完成"记录没有回文单号

---

## 🔍 问题根源分析

### 根本原因：Registry可能创建了重复的任务记录

根据用户描述和代码分析，怀疑是以下原因导致：

#### 原因1：文件6的唯一性键（UNIQUE约束）问题

数据库的UNIQUE约束：
```sql
UNIQUE(file_type, project_id, interface_id, source_file, row_index)
```

**问题**：
- 如果同一接口在同一文件中出现在**不同行**（`row_index`不同）
- 或者`responsible_person`从无到有的变化
- 可能会创建多条记录

#### 原因2：文件6项目号提取逻辑

文件6的项目号逻辑（`registry/util.py`）：
```python
# 文件6特殊处理：空值统一为"未知项目"
if file_type == 6 and (not project_id or project_id.lower() in ['nan', 'none', '']):
    return "未知项目"
```

**问题**：
- 如果项目号为空，会设置为"未知项目"
- 这可能导致不同项目的接口被合并
- 或者同一接口因项目号变化被创建多次

#### 原因3：责任人列变化触发新记录

在`batch_upsert_tasks`中，如果检测到责任人从无到有：
- 可能触发状态重置逻辑
- `display_status`从"待完成"变为"请指派"（如果责任人为空）

---

## 🎯 诊断要点

### 1. 检查Excel文件
```
操作：
1. 打开文件6的Excel源文件
2. 找到出问题的接口行
3. 检查：
   - E列（接口号）
   - X列（责任人）- 索引23
   - L列（回文单号）- 索引11
   - J列（完成时间）- 索引9
   - N列（写入人）- 索引13
```

### 2. 检查数据库记录

运行以下SQL查询：
```sql
SELECT 
    id, project_id, interface_id, source_file, row_index,
    business_id, status, display_status, responsible_person, 
    response_number, completed_at, first_seen_at
FROM tasks
WHERE file_type = 6 AND interface_id = '您的接口号'
ORDER BY first_seen_at;
```

**检查项**：
- 是否有多条记录？
- `row_index`是否不同？
- `responsible_person`是否不同？
- `business_id`是否相同？

---

## ✅ 修复方案

### 方案1：增强唯一性约束（推荐）

**问题**：现在的UNIQUE约束基于`(file_type, project_id, interface_id, source_file, row_index)`  
**改进**：应该基于`business_id`（接口号继承的关键）

**修改`registry/db.py`**：

```python
CREATE TABLE IF NOT EXISTS tasks (
    id TEXT PRIMARY KEY,
    file_type INTEGER NOT NULL,
    project_id TEXT NOT NULL,
    interface_id TEXT NOT NULL,
    source_file TEXT NOT NULL,
    row_index INTEGER NOT NULL,
    business_id TEXT DEFAULT NULL,
    ...
    UNIQUE(file_type, project_id, interface_id, source_file, row_index),
    UNIQUE(business_id)  -- 【新增】确保每个业务ID只有一条记录
);
```

但这会引入问题：如果同一接口在不同source_file中出现，会冲突。

### 方案2：改进写入回文单号逻辑（临时修复）

**问题分析**：
当用户写入回文单号时：
1. `input_handler.py`写入Excel（L列、J列、N列）
2. `registry/hooks.py`的`on_response_written`记录到数据库
3. 但可能记录到了错误的任务ID

**检查点**：
- `on_response_written`接收的`row_index`是否正确？
- 是否找到了正确的任务记录？

---

## 🔧 临时修复措施

### 步骤1：清理重复记录

创建清理脚本（`scripts/clean_file6_duplicates.py`）：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""清理文件6的重复记录"""

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from registry.hooks import _cfg
from registry.db import get_connection

def clean_duplicates():
    """清理文件6的重复接口记录"""
    cfg = _cfg()
    db_path = cfg.get('registry_db_path')
    
    if not db_path or not os.path.exists(db_path):
        print(f"数据库不存在: {db_path}")
        return
    
    conn = get_connection(db_path, True)
    
    # 1. 找到所有重复的business_id
    cursor = conn.execute("""
        SELECT business_id, COUNT(*) as cnt
        FROM tasks
        WHERE file_type = 6 AND business_id IS NOT NULL
        GROUP BY business_id
        HAVING cnt > 1
    """)
    
    duplicates = cursor.fetchall()
    
    if not duplicates:
        print("没有发现重复记录")
        return
    
    print(f"发现{len(duplicates)}个重复的business_id")
    
    for bid, cnt in duplicates:
        print(f"\n处理 business_id: {bid}")
        
        # 获取所有相关记录
        cursor = conn.execute("""
            SELECT id, project_id, interface_id, row_index, first_seen_at, 
                   status, display_status, responsible_person, response_number,
                   completed_at, confirmed_at
            FROM tasks
            WHERE business_id = ?
            ORDER BY first_seen_at DESC
        """, (bid,))
        
        records = cursor.fetchall()
        
        # 选择最新的记录作为主记录
        primary = records[0]
        print(f"  保留最新记录: {primary[0]}")
        print(f"    - status: {primary[5]}")
        print(f"    - display_status: {primary[6]}")
        print(f"    - responsible_person: {primary[7]}")
        print(f"    - response_number: {primary[8]}")
        
        # 删除其他记录
        for record in records[1:]:
            print(f"  删除旧记录: {record[0]}")
            conn.execute("DELETE FROM tasks WHERE id = ?", (record[0],))
    
    conn.commit()
    print(f"\n清理完成！删除了{sum(cnt-1 for _, cnt in duplicates)}条重复记录")

if __name__ == "__main__":
    clean_duplicates()
```

### 步骤2：验证Excel写入

检查`input_handler.py`的写入逻辑：

```python
# 文件6配置
6: {'response_col': 'L', 'time_col': 'J', 'name_col': 'N'},
```

**验证**：
- L列（索引11）- 回文单号 ✅
- J列（索引9）- 完成时间 ✅
- N列（索引13）- 写入人 ✅

配置正确！

### 步骤3：增强日志输出

在`input_handler.py`的`write_response_to_excel`函数中增加日志：

```python
# 写入数据
ws[f"{response_col}{row_index}"] = response_number
ws[f"{time_col}{row_index}"] = date.today().strftime('%Y-%m-%d')
ws[f"{name_col}{row_index}"] = user_name

# 【新增】验证写入
print(f"[文件6写入验证] 行号:{row_index}")
print(f"  - {response_col}{row_index} = {response_number}")
print(f"  - {time_col}{row_index} = {date.today().strftime('%Y-%m-%d')}")
print(f"  - {name_col}{row_index} = {user_name}")
```

---

## 📋 用户操作指南

### 立即操作：检查当前状态

#### 1. 查看Excel文件
```
1. 打开文件6的源Excel文件
2. 找到出问题的接口行
3. 检查L列是否有回文单号
4. 检查J列是否有完成时间
5. 检查N列是否有写入人
```

**如果Excel中没有数据**：
- 说明写入失败
- 可能是文件被锁定
- 或者row_index不正确

**如果Excel中有数据**：
- 说明写入成功
- 问题在于Registry记录

#### 2. 提供关键信息

请提供以下信息以便进一步诊断：

```
1. 出问题的接口号是什么？（E列）
2. 项目号是什么？（从文件名提取，如"收发文清单2016.xlsx" → 2016）
3. 责任人列（X列）的内容是什么？
4. 在程序中写入回文单号时的控制台输出（完整日志）
```

#### 3. 运行诊断

如果您可以访问数据库，请运行：

```sql
-- 查找该接口的所有记录
SELECT 
    id, project_id, interface_id, row_index,
    business_id, status, display_status, responsible_person, 
    response_number, first_seen_at
FROM tasks
WHERE file_type = 6 AND interface_id = '您的接口号'
ORDER BY first_seen_at;
```

---

## 🎯 长期修复建议

### 1. 改进business_id生成逻辑

确保文件6的business_id生成一致：

```python
def make_business_id(file_type: int, project_id: str, interface_id: str) -> str:
    """
    生成业务ID（用于接口号继承）
    
    对于文件6：
    - 如果project_id为空或"未知项目"，使用interface_id作为business_id
    - 否则使用 file_type|project_id|interface_id
    """
    if file_type == 6 and (not project_id or project_id == "未知项目"):
        return f"6||{interface_id}"
    return f"{file_type}|{project_id}|{interface_id}"
```

### 2. 统一责任人判断逻辑

```python
def should_display_as_assign(responsible_person: str) -> bool:
    """判断是否应该显示为"请指派"""
    if not responsible_person:
        return True
    if responsible_person.lower() in ['nan', 'none', '无', '']:
        return True
    return False
```

### 3. 增强写入验证

在写入回文单号后立即验证：

```python
# 写入后验证
wb.save(file_path)
wb.close()

# 重新打开验证
wb_verify = load_workbook(file_path)
ws_verify = wb_verify.active
actual_value = ws_verify[f"{response_col}{row_index}"].value
wb_verify.close()

if actual_value != response_number:
    print(f"[警告] 写入验证失败: 预期={response_number}, 实际={actual_value}")
else:
    print(f"[成功] 写入验证通过: {response_number}")
```

---

## ⚠️ 紧急修复步骤

如果用户现在就遇到此问题，请按以下步骤操作：

### 步骤1：停止使用程序
- 避免创建更多重复记录

### 步骤2：备份数据
```
备份以下文件：
1. D:\Programs\接口筛选\测试文件\.registry\registry.db
2. 文件6的Excel源文件
```

### 步骤3：清理数据库（可选）
```
选项A：删除registry.db，重新开始（会丢失历史）
选项B：运行清理脚本（保留最新记录）
```

### 步骤4：重新测试
```
1. 重启程序
2. 点击"开始处理"
3. 检查文件6接口是否正常显示
4. 尝试写入回文单号
5. 验证Excel文件是否正确写入
6. 检查历史查询是否只有一条记录
```

---

## ✅ 验证清单

| 检查项 | 预期结果 | 实际结果 |
|--------|---------|---------|
| Excel L列有回文单号 | ✅ 有 | ⏳ 待检查 |
| Excel J列有完成时间 | ✅ 有 | ⏳ 待检查 |
| Excel N列有写入人 | ✅ 有 | ⏳ 待检查 |
| 数据库只有一条记录 | ✅ 是 | ⏳ 待检查 |
| 状态显示正确 | ✅ 待完成/待审查 | ⏳ 待检查 |
| 历史查询只显示一条 | ✅ 是 | ⏳ 待检查 |

---

**报告生成时间**: 2025-11-10  
**状态**: 待用户提供更多诊断信息

