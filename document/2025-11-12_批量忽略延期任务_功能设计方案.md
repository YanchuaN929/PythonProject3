# æ‰¹é‡å¿½ç•¥å»¶æœŸä»»åŠ¡åŠŸèƒ½ - è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ éœ€æ±‚æ¦‚è¿°

### æ ¸å¿ƒéœ€æ±‚
1. **æ“ä½œæƒé™**ï¼šä»…"æ‰€é¢†å¯¼"è§’è‰²å¯ä»¥ä½¿ç”¨æ­¤åŠŸèƒ½
2. **æ“ä½œå¯¹è±¡**ï¼šæ‰€æœ‰çŠ¶æ€ä¸º"å·²å»¶æœŸ"çš„æ¥å£
3. **æ“ä½œåç§°**ï¼šæ‰¹é‡"å¿½ç•¥"
4. **å¿½ç•¥æ•ˆæœ**ï¼šè¢«æ ‡è®°ä¸º"å¿½ç•¥"çš„æ¥å£å°†ï¼š
   - âŒ ä¸åœ¨ä¸»æ˜¾ç¤ºçª—å£æ˜¾ç¤ºï¼ˆæ‰€æœ‰è§’è‰²ï¼‰
   - âŒ ä¸åœ¨çŠ¶æ€æé†’ä¸­å‡ºç°
   - âŒ ä¸åœ¨å¯¼å‡ºç»“æœä¸­åŒ…å«
5. **è‡ªåŠ¨å–æ¶ˆå¿½ç•¥**ï¼šå½“è¢«å¿½ç•¥æ¥å£çš„é¢„æœŸæ—¶é—´åˆ—æœ‰å˜åŒ–æ—¶ï¼ˆå°¤å…¶æ˜¯å‘åå˜åŒ–ï¼Œå¦‚2025-08-10â†’2026-01-01ï¼Œæ³¨æ„æ ¼å¼å’Œç°åœ¨çš„å…¼å®¹ï¼‰ï¼Œæ ‡è®°è‡ªåŠ¨å–æ¶ˆ

### UIè¦æ±‚
- ç±»ä¼¼"è¯·æŒ‡æ´¾"æŒ‰é’®çš„å®Œæ•´GUIé€»è¾‘
- åŒ…æ‹¬æŒ‰é’®ã€å¼¹çª—ã€æ˜¾ç¤ºæ–¹å¼ã€æ“ä½œé€»è¾‘ç­‰

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### 1. æ•°æ®åº“Schemaä¿®æ”¹

#### tasksè¡¨æ–°å¢å­—æ®µ

```sql
ALTER TABLE tasks ADD COLUMN ignored INTEGER DEFAULT 0;              -- æ˜¯å¦è¢«å¿½ç•¥ (0=å¦, 1=æ˜¯)
ALTER TABLE tasks ADD COLUMN ignored_at TEXT DEFAULT NULL;           -- å¿½ç•¥æ—¶é—´
ALTER TABLE tasks ADD COLUMN ignored_by TEXT DEFAULT NULL;           -- å¿½ç•¥æ“ä½œäºº
ALTER TABLE tasks ADD COLUMN interface_time_when_ignored TEXT DEFAULT NULL;  -- å¿½ç•¥æ—¶çš„é¢„æœŸæ—¶é—´ï¼ˆç”¨äºæ£€æµ‹å˜åŒ–ï¼‰
ALTER TABLE tasks ADD COLUMN ignored_reason TEXT DEFAULT NULL;       -- å¿½ç•¥åŸå› ï¼ˆå¯é€‰ï¼Œä¾›ç”¨æˆ·å¡«å†™ï¼‰
```

#### ç´¢å¼•ä¼˜åŒ–

```sql
CREATE INDEX IF NOT EXISTS idx_tasks_ignored ON tasks(ignored, status);
```

**è®¾è®¡è¯´æ˜**ï¼š
- `ignored`: 0/1æ ‡å¿—ä½ï¼Œä¾¿äºå¿«é€ŸæŸ¥è¯¢
- `interface_time_when_ignored`: ä¿å­˜å¿½ç•¥æ—¶çš„é¢„æœŸæ—¶é—´ï¼Œç”¨äºåç»­æ£€æµ‹æ˜¯å¦å˜åŒ–
- `ignored_reason`: å¯é€‰å­—æ®µï¼Œå…è®¸æ‰€é¢†å¯¼è®°å½•å¿½ç•¥åŸå› ï¼ˆå¦‚"é•¿æœŸæ‹–å»¶""ä¸å†éœ€è¦"ç­‰ï¼‰

---

### 2. RegistryæœåŠ¡å±‚ä¿®æ”¹

#### 2.1 æ–°å¢å‡½æ•°ï¼šmark_ignored

**æ–‡ä»¶**: `registry/service.py`

**åŠŸèƒ½**: æ‰¹é‡æ ‡è®°ä»»åŠ¡ä¸º"å¿½ç•¥"çŠ¶æ€

```python
def mark_ignored_batch(
    db_path: str, 
    wal: bool, 
    task_keys: List[Dict[str, Any]], 
    ignored_by: str,
    ignored_reason: str = "",
    now: datetime = None
) -> Dict[str, Any]:
    """
    æ‰¹é‡æ ‡è®°ä»»åŠ¡ä¸º"å¿½ç•¥"çŠ¶æ€
    
    å‚æ•°:
        db_path: æ•°æ®åº“è·¯å¾„
        wal: æ˜¯å¦ä½¿ç”¨WALæ¨¡å¼
        task_keys: ä»»åŠ¡keyåˆ—è¡¨ï¼Œæ¯ä¸ªkeyåŒ…å« file_type, project_id, interface_id, 
                   source_file, row_index, interface_time
        ignored_by: å¿½ç•¥æ“ä½œäºº
        ignored_reason: å¿½ç•¥åŸå› ï¼ˆå¯é€‰ï¼‰
        now: å½“å‰æ—¶é—´
    
    è¿”å›:
        {
            'success_count': int,  # æˆåŠŸæ ‡è®°çš„æ•°é‡
            'failed_tasks': [...]  # å¤±è´¥çš„ä»»åŠ¡åˆ—è¡¨
        }
    """
    if now is None:
        now = datetime.now()
    
    conn = get_connection(db_path, wal)
    success_count = 0
    failed_tasks = []
    
    for key in task_keys:
        try:
            # 1. æŸ¥æ‰¾ä»»åŠ¡ï¼ˆä½¿ç”¨business_idæŸ¥æ‰¾æœ€æ–°éå½’æ¡£ä»»åŠ¡ï¼‰
            business_id = make_business_id(
                key['file_type'], 
                key['project_id'], 
                key['interface_id']
            )
            
            cursor = conn.execute("""
                SELECT id, status, ignored 
                FROM tasks
                WHERE business_id = ?
                  AND status != 'archived'
                ORDER BY last_seen_at DESC
                LIMIT 1
            """, (business_id,))
            
            row = cursor.fetchone()
            if not row:
                failed_tasks.append({
                    'interface_id': key['interface_id'],
                    'reason': 'ä»»åŠ¡ä¸å­˜åœ¨'
                })
                continue
            
            tid, status, already_ignored = row
            
            # 2. æ£€æŸ¥æ˜¯å¦å·²ç»è¢«å¿½ç•¥
            if already_ignored == 1:
                failed_tasks.append({
                    'interface_id': key['interface_id'],
                    'reason': 'å·²ç»è¢«å¿½ç•¥'
                })
                continue
            
            # 3. æ ‡è®°ä¸ºå¿½ç•¥
            interface_time = key.get('interface_time', '')
            conn.execute("""
                UPDATE tasks
                SET ignored = 1,
                    ignored_at = ?,
                    ignored_by = ?,
                    interface_time_when_ignored = ?,
                    ignored_reason = ?
                WHERE id = ?
            """, (
                now.isoformat(),
                ignored_by,
                interface_time,
                ignored_reason,
                tid
            ))
            
            success_count += 1
            print(f"[Registryå¿½ç•¥] âœ“ å·²å¿½ç•¥: {key['interface_id']} (é¢„æœŸæ—¶é—´: {interface_time})")
            
        except Exception as e:
            failed_tasks.append({
                'interface_id': key.get('interface_id', 'æœªçŸ¥'),
                'reason': str(e)
            })
            print(f"[Registryå¿½ç•¥] âœ— å¤±è´¥: {key.get('interface_id', 'æœªçŸ¥')} - {e}")
    
    conn.commit()
    
    return {
        'success_count': success_count,
        'failed_tasks': failed_tasks
    }
```

---

#### 2.2 æ–°å¢å‡½æ•°ï¼šcheck_and_auto_unignore

**æ–‡ä»¶**: `registry/service.py`

**åŠŸèƒ½**: æ£€æµ‹è¢«å¿½ç•¥ä»»åŠ¡çš„é¢„æœŸæ—¶é—´å˜åŒ–ï¼Œè‡ªåŠ¨å–æ¶ˆå¿½ç•¥

```python
def check_and_auto_unignore(
    db_path: str,
    wal: bool,
    task_key: Dict[str, Any],
    current_interface_time: str
) -> bool:
    """
    æ£€æµ‹è¢«å¿½ç•¥ä»»åŠ¡çš„é¢„æœŸæ—¶é—´æ˜¯å¦å˜åŒ–ï¼Œå¦‚å˜åŒ–åˆ™è‡ªåŠ¨å–æ¶ˆå¿½ç•¥
    
    å‚æ•°:
        db_path: æ•°æ®åº“è·¯å¾„
        wal: æ˜¯å¦ä½¿ç”¨WALæ¨¡å¼
        task_key: ä»»åŠ¡keyï¼ŒåŒ…å« file_type, project_id, interface_id
        current_interface_time: å½“å‰æ‰«æåˆ°çš„é¢„æœŸæ—¶é—´
    
    è¿”å›:
        bool: Trueè¡¨ç¤ºå–æ¶ˆäº†å¿½ç•¥ï¼ŒFalseè¡¨ç¤ºæœªæ“ä½œ
    """
    conn = get_connection(db_path, wal)
    
    # 1. æŸ¥æ‰¾ä»»åŠ¡
    business_id = make_business_id(
        task_key['file_type'],
        task_key['project_id'],
        task_key['interface_id']
    )
    
    cursor = conn.execute("""
        SELECT id, ignored, interface_time_when_ignored
        FROM tasks
        WHERE business_id = ?
          AND status != 'archived'
          AND ignored = 1
        ORDER BY last_seen_at DESC
        LIMIT 1
    """, (business_id,))
    
    row = cursor.fetchone()
    if not row:
        return False  # ä»»åŠ¡ä¸å­˜åœ¨æˆ–æœªè¢«å¿½ç•¥
    
    tid, ignored, old_interface_time = row
    
    # 2. æ£€æŸ¥interface_timeæ˜¯å¦å˜åŒ–
    if current_interface_time != old_interface_time:
        # æ—¶é—´å‘ç”Ÿå˜åŒ–ï¼Œå–æ¶ˆå¿½ç•¥
        conn.execute("""
            UPDATE tasks
            SET ignored = 0,
                ignored_at = NULL,
                ignored_by = NULL,
                interface_time_when_ignored = NULL,
                ignored_reason = NULL
            WHERE id = ?
        """, (tid,))
        conn.commit()
        
        print(f"[Registryè‡ªåŠ¨å–æ¶ˆå¿½ç•¥] âœ“ {task_key['interface_id']}")
        print(f"  åŸé¢„æœŸæ—¶é—´: {old_interface_time}")
        print(f"  æ–°é¢„æœŸæ—¶é—´: {current_interface_time}")
        return True
    
    return False
```

---

#### 2.3 ä¿®æ”¹å‡½æ•°ï¼šupsert_task

**æ–‡ä»¶**: `registry/service.py`

**ä½ç½®**: åœ¨`upsert_task`å‡½æ•°ä¸­æ·»åŠ å¿½ç•¥æ£€æµ‹é€»è¾‘

```python
def upsert_task(...):
    # ... ç°æœ‰ä»£ç  ...
    
    # ã€æ–°å¢ã€‘åœ¨æ›´æ–°ä»»åŠ¡å‰ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨å–æ¶ˆå¿½ç•¥
    if old_task and old_task.get('ignored') == 1:
        old_interface_time = old_task.get('interface_time_when_ignored', '')
        current_interface_time = fields.get('interface_time', '')
        
        if current_interface_time != old_interface_time:
            # è‡ªåŠ¨å–æ¶ˆå¿½ç•¥
            fields['ignored'] = 0
            fields['ignored_at'] = None
            fields['ignored_by'] = None
            fields['interface_time_when_ignored'] = None
            fields['ignored_reason'] = None
            
            print(f"[Registry] æ£€æµ‹åˆ°é¢„æœŸæ—¶é—´å˜åŒ–ï¼Œè‡ªåŠ¨å–æ¶ˆå¿½ç•¥: {key['interface_id']}")
            print(f"  åŸé¢„æœŸæ—¶é—´: {old_interface_time}")
            print(f"  æ–°é¢„æœŸæ—¶é—´: {current_interface_time}")
    
    # ... ç»§ç»­ç°æœ‰çš„upserté€»è¾‘ ...
```

---

#### 2.4 ä¿®æ”¹å‡½æ•°ï¼šget_display_status

**æ–‡ä»¶**: `registry/service.py`

**ä½ç½®**: åœ¨`get_display_status`å‡½æ•°å¼€å¤´æ·»åŠ å¿½ç•¥è¿‡æ»¤

```python
def get_display_status(db_path: str, wal: bool, task_keys: List[Dict[str, Any]], current_user_roles: List[str] = None) -> Dict[str, str]:
    """æ‰¹é‡æŸ¥è¯¢ä»»åŠ¡çš„æ˜¾ç¤ºçŠ¶æ€ï¼ˆç”¨äºUIæ˜¾ç¤ºï¼‰"""
    if not task_keys:
        return {}
    
    conn = get_connection(db_path, wal)
    result = {}
    
    # ... ç°æœ‰çš„è§’è‰²åˆ¤æ–­é€»è¾‘ ...
    
    for key in task_keys:
        tid = make_task_id(...)
        
        # æŸ¥è¯¢ä»»åŠ¡ä¿¡æ¯
        cursor = conn.execute(
            """
            SELECT status, display_status, assigned_by, role, confirmed_at, 
                   responsible_person, ignored
            FROM tasks
            WHERE id = ?
            """,
            (tid,)
        )
        row = cursor.fetchone()
        
        if not row:
            continue
        
        status, display_status, assigned_by, role, confirmed_at, responsible_person, ignored = row
        
        # ã€æ–°å¢ã€‘å¦‚æœä»»åŠ¡è¢«å¿½ç•¥ï¼Œä¸è¿”å›ä»»ä½•çŠ¶æ€ï¼ˆUIä¸­ä¼šè¢«è¿‡æ»¤ï¼‰
        if ignored == 1:
            result[tid] = ''  # ç©ºå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸æ˜¾ç¤º
            continue
        
        # ... ç»§ç»­ç°æœ‰çš„çŠ¶æ€åˆ¤æ–­é€»è¾‘ ...
```

---

### 3. UIå±‚ä¿®æ”¹

#### 3.1 æ–°å¢æŒ‰é’®ï¼šå¿½ç•¥å»¶æœŸé¡¹

**æ–‡ä»¶**: `base.py`

**ä½ç½®**: åœ¨`create_button_panel`æ–¹æ³•ä¸­ï¼Œ"è¯·æŒ‡æ´¾"æŒ‰é’®é™„è¿‘

```python
def create_button_panel(self, parent):
    # ... ç°æœ‰æŒ‰é’® ...
    
    # ã€æ–°å¢ã€‘å¿½ç•¥å»¶æœŸé¡¹æŒ‰é’®ï¼ˆä»…æ‰€é¢†å¯¼å¯è§ï¼‰
    if self.current_user_role and 'æ‰€é¢†å¯¼' in self.current_user_role:
        ignore_btn = ttk.Button(
            button_frame,
            text="å¿½ç•¥å»¶æœŸé¡¹",
            command=self._on_ignore_overdue_button_click,
            style='Action.TButton'
        )
        ignore_btn.pack(side='left', padx=5)
        
        # æ·»åŠ æç¤º
        self._create_tooltip(ignore_btn, "æ‰¹é‡å¿½ç•¥å·²å»¶æœŸçš„æ¥å£ï¼ˆæ‰€é¢†å¯¼ä¸“ç”¨ï¼‰")
```

---

#### 3.2 æ–°å¢å¼¹çª—ï¼šIgnoreOverdueDialog

**æ–‡ä»¶**: æ–°å»º`ignore_overdue_dialog.py`

**åŠŸèƒ½**: ç±»ä¼¼`AssignmentDialog`çš„æ‰¹é‡å¿½ç•¥å¯¹è¯æ¡†

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
æ‰¹é‡å¿½ç•¥å»¶æœŸä»»åŠ¡å¯¹è¯æ¡†
"""

import tkinter as tk
from tkinter import ttk, messagebox
from typing import List, Dict, Any
from datetime import datetime


class IgnoreOverdueDialog(tk.Toplevel):
    """æ‰¹é‡å¿½ç•¥å»¶æœŸä»»åŠ¡å¯¹è¯æ¡†"""
    
    def __init__(self, parent, overdue_tasks: List[Dict[str, Any]], user_name: str):
        """
        åˆå§‹åŒ–å¯¹è¯æ¡†
        
        å‚æ•°:
            parent: çˆ¶çª—å£
            overdue_tasks: å»¶æœŸä»»åŠ¡åˆ—è¡¨ï¼Œæ¯ä¸ªä»»åŠ¡åŒ…å«:
                {
                    'file_type': int,
                    'project_id': str,
                    'interface_id': str,
                    'source_file': str,
                    'row_index': int,
                    'interface_time': str,
                    'status': str,  # çŠ¶æ€æ–‡æœ¬ï¼ˆå¦‚"ï¼ˆå·²å»¶æœŸï¼‰å¾…å®Œæˆ"ï¼‰
                }
            user_name: å½“å‰ç”¨æˆ·å§“å
        """
        super().__init__(parent)
        
        self.overdue_tasks = overdue_tasks
        self.user_name = user_name
        self.selected_indices = set()  # é€‰ä¸­çš„ä»»åŠ¡ç´¢å¼•
        self.ignore_reason_var = tk.StringVar()  # å¿½ç•¥åŸå› 
        self.ignore_successful = False  # æ ‡è®°æ˜¯å¦æˆåŠŸå¿½ç•¥
        
        self.setup_ui()
    
    def setup_ui(self):
        """è®¾ç½®ç•Œé¢"""
        self.title("æ‰¹é‡å¿½ç•¥å»¶æœŸä»»åŠ¡")
        self.geometry("1000x700")
        
        # å±…ä¸­æ˜¾ç¤º
        self.transient(self.master)
        self.grab_set()
        
        # æ ‡é¢˜
        title_label = ttk.Label(
            self,
            text=f"æ‰¹é‡å¿½ç•¥å»¶æœŸä»»åŠ¡ï¼ˆå…±{len(self.overdue_tasks)}ä¸ªå·²å»¶æœŸä»»åŠ¡ï¼‰",
            font=('Arial', 14, 'bold')
        )
        title_label.pack(pady=10)
        
        # è¯´æ˜æ–‡å­—
        info_label = ttk.Label(
            self,
            text="è¯´æ˜ï¼šè¢«å¿½ç•¥çš„ä»»åŠ¡å°†ä¸å†åœ¨ä¸»æ˜¾ç¤ºã€çŠ¶æ€æé†’å’Œå¯¼å‡ºç»“æœä¸­å‡ºç°\n"
                 "å½“ä»»åŠ¡çš„é¢„æœŸæ—¶é—´å‘ç”Ÿå˜åŒ–æ—¶ï¼Œå¿½ç•¥æ ‡è®°ä¼šè‡ªåŠ¨å–æ¶ˆ",
            font=('Arial', 10),
            foreground='gray'
        )
        info_label.pack(pady=5)
        
        # åˆ›å»ºä»»åŠ¡åˆ—è¡¨åŒºåŸŸ
        self._create_task_list_frame()
        
        # åˆ›å»ºæ“ä½œæ 
        self._create_action_frame()
        
        # åˆ›å»ºæŒ‰é’®æ 
        self._create_button_frame()
    
    def _create_task_list_frame(self):
        """åˆ›å»ºä»»åŠ¡åˆ—è¡¨åŒºåŸŸ"""
        list_frame = ttk.Frame(self)
        list_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # åˆ›å»ºTreeview
        columns = ('é€‰æ‹©', 'é¡¹ç›®å·', 'æ¥å£å·', 'é¢„æœŸæ—¶é—´', 'çŠ¶æ€')
        self.tree = ttk.Treeview(
            list_frame,
            columns=columns,
            show='headings',
            selectmode='extended'
        )
        
        # è®¾ç½®åˆ—
        self.tree.heading('é€‰æ‹©', text='â˜ å…¨é€‰')
        self.tree.heading('é¡¹ç›®å·', text='é¡¹ç›®å·')
        self.tree.heading('æ¥å£å·', text='æ¥å£å·')
        self.tree.heading('é¢„æœŸæ—¶é—´', text='é¢„æœŸæ—¶é—´')
        self.tree.heading('çŠ¶æ€', text='çŠ¶æ€')
        
        self.tree.column('é€‰æ‹©', width=80, anchor='center')
        self.tree.column('é¡¹ç›®å·', width=120, anchor='center')
        self.tree.column('æ¥å£å·', width=350, anchor='w')
        self.tree.column('é¢„æœŸæ—¶é—´', width=120, anchor='center')
        self.tree.column('çŠ¶æ€', width=200, anchor='center')
        
        # æ·»åŠ æ»šåŠ¨æ¡
        scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        
        self.tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
        
        # å¡«å……æ•°æ®
        for idx, task in enumerate(self.overdue_tasks):
            self.tree.insert('', 'end', iid=str(idx), values=(
                'â˜',  # é»˜è®¤æœªé€‰ä¸­
                task['project_id'],
                task['interface_id'],
                task['interface_time'],
                task.get('status', 'å·²å»¶æœŸ')
            ))
        
        # ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼ˆåˆ‡æ¢é€‰ä¸­çŠ¶æ€ï¼‰
        self.tree.bind('<Button-1>', self._on_tree_click)
        
        # ç»‘å®šå…¨é€‰æ ‡é¢˜ç‚¹å‡»
        self.tree.heading('é€‰æ‹©', command=self._toggle_select_all)
    
    def _on_tree_click(self, event):
        """ç‚¹å‡»ä»»åŠ¡è¡Œï¼Œåˆ‡æ¢é€‰ä¸­çŠ¶æ€"""
        region = self.tree.identify_region(event.x, event.y)
        if region != 'cell':
            return
        
        item_id = self.tree.identify_row(event.y)
        if not item_id:
            return
        
        idx = int(item_id)
        
        # åˆ‡æ¢é€‰ä¸­çŠ¶æ€
        if idx in self.selected_indices:
            self.selected_indices.remove(idx)
            self.tree.set(item_id, 'é€‰æ‹©', 'â˜')
        else:
            self.selected_indices.add(idx)
            self.tree.set(item_id, 'é€‰æ‹©', 'â˜‘')
    
    def _toggle_select_all(self):
        """åˆ‡æ¢å…¨é€‰/å…¨ä¸é€‰"""
        if len(self.selected_indices) == len(self.overdue_tasks):
            # å…¨éƒ¨å–æ¶ˆé€‰ä¸­
            self.selected_indices.clear()
            for idx in range(len(self.overdue_tasks)):
                self.tree.set(str(idx), 'é€‰æ‹©', 'â˜')
            self.tree.heading('é€‰æ‹©', text='â˜ å…¨é€‰')
        else:
            # å…¨éƒ¨é€‰ä¸­
            self.selected_indices = set(range(len(self.overdue_tasks)))
            for idx in range(len(self.overdue_tasks)):
                self.tree.set(str(idx), 'é€‰æ‹©', 'â˜‘')
            self.tree.heading('é€‰æ‹©', text='â˜‘ å…¨é€‰')
    
    def _create_action_frame(self):
        """åˆ›å»ºæ“ä½œæ ï¼ˆå¿½ç•¥åŸå› è¾“å…¥ï¼‰"""
        action_frame = ttk.LabelFrame(self, text="å¿½ç•¥åŸå› ï¼ˆå¯é€‰ï¼‰", padding=10)
        action_frame.pack(fill='x', padx=10, pady=10)
        
        # é¢„è®¾åŸå› æŒ‰é’®
        preset_frame = ttk.Frame(action_frame)
        preset_frame.pack(fill='x', pady=5)
        
        ttk.Label(preset_frame, text="å¿«é€Ÿé€‰æ‹©ï¼š").pack(side='left', padx=5)
        
        preset_reasons = [
            "é•¿æœŸæ‹–å»¶",
            "ä¼˜å…ˆçº§ä½",
            "æš‚ä¸å¤„ç†",
            "ç­‰å¾…å¤–éƒ¨æ¡ä»¶",
            "ä¸å†éœ€è¦"
        ]
        
        for reason in preset_reasons:
            btn = ttk.Button(
                preset_frame,
                text=reason,
                command=lambda r=reason: self.ignore_reason_var.set(r),
                width=12
            )
            btn.pack(side='left', padx=3)
        
        # è‡ªå®šä¹‰è¾“å…¥æ¡†
        input_frame = ttk.Frame(action_frame)
        input_frame.pack(fill='x', pady=5)
        
        ttk.Label(input_frame, text="æˆ–è‡ªå®šä¹‰ï¼š").pack(side='left', padx=5)
        
        reason_entry = ttk.Entry(
            input_frame,
            textvariable=self.ignore_reason_var,
            font=('Arial', 10),
            width=50
        )
        reason_entry.pack(side='left', padx=5, fill='x', expand=True)
    
    def _create_button_frame(self):
        """åˆ›å»ºæŒ‰é’®æ """
        button_frame = ttk.Frame(self)
        button_frame.pack(fill='x', padx=10, pady=10)
        
        # ç¡®è®¤æŒ‰é’®
        confirm_btn = ttk.Button(
            button_frame,
            text=f"ç¡®è®¤å¿½ç•¥é€‰ä¸­ä»»åŠ¡",
            command=self._on_confirm,
            style='Action.TButton'
        )
        confirm_btn.pack(side='left', padx=5)
        
        # å–æ¶ˆæŒ‰é’®
        cancel_btn = ttk.Button(
            button_frame,
            text="å–æ¶ˆ",
            command=self.destroy
        )
        cancel_btn.pack(side='left', padx=5)
        
        # ç»Ÿè®¡ä¿¡æ¯
        self.info_label = ttk.Label(
            button_frame,
            text=f"å·²é€‰ä¸­ 0 ä¸ªä»»åŠ¡",
            font=('Arial', 10),
            foreground='blue'
        )
        self.info_label.pack(side='right', padx=10)
        
        # å®šæ—¶æ›´æ–°ç»Ÿè®¡
        self._update_selection_info()
    
    def _update_selection_info(self):
        """æ›´æ–°é€‰ä¸­ä»»åŠ¡ç»Ÿè®¡"""
        count = len(self.selected_indices)
        self.info_label.config(text=f"å·²é€‰ä¸­ {count} ä¸ªä»»åŠ¡")
        self.after(500, self._update_selection_info)
    
    def _on_confirm(self):
        """ç¡®è®¤æŒ‰é’®å›è°ƒ"""
        if not self.selected_indices:
            messagebox.showwarning("æç¤º", "è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªä»»åŠ¡è¿›è¡Œå¿½ç•¥", parent=self)
            return
        
        # äºŒæ¬¡ç¡®è®¤
        count = len(self.selected_indices)
        reason = self.ignore_reason_var.get().strip()
        
        msg = f"ç¡®è®¤è¦å¿½ç•¥é€‰ä¸­çš„ {count} ä¸ªå»¶æœŸä»»åŠ¡å—ï¼Ÿ\n\n"
        msg += "è¢«å¿½ç•¥çš„ä»»åŠ¡å°†ä¸å†æ˜¾ç¤ºï¼Œç›´åˆ°å…¶é¢„æœŸæ—¶é—´å‘ç”Ÿå˜åŒ–ã€‚"
        if reason:
            msg += f"\n\nå¿½ç•¥åŸå› ï¼š{reason}"
        
        if not messagebox.askyesno("ç¡®è®¤å¿½ç•¥", msg, parent=self):
            return
        
        # æ˜¾ç¤ºå¤„ç†ä¸­æç¤º
        processing_label = ttk.Label(
            self,
            text="æ­£åœ¨æ‰¹é‡å¿½ç•¥ï¼Œè¯·ç¨å€™...",
            font=('Arial', 12)
        )
        processing_label.pack(pady=10)
        self.update()
        
        # æ‰§è¡Œæ‰¹é‡å¿½ç•¥
        try:
            # å‡†å¤‡ä»»åŠ¡åˆ—è¡¨
            selected_tasks = [
                self.overdue_tasks[idx] for idx in self.selected_indices
            ]
            
            # è°ƒç”¨RegistryæœåŠ¡
            from registry import service as registry_service
            from registry.db import get_connection
            from registry.config import get_config
            
            cfg = get_config()
            db_path = cfg['db_path']
            wal = cfg.get('wal', True)
            
            task_keys = []
            for task in selected_tasks:
                task_keys.append({
                    'file_type': task['file_type'],
                    'project_id': task['project_id'],
                    'interface_id': task['interface_id'],
                    'source_file': task['source_file'],
                    'row_index': task['row_index'],
                    'interface_time': task['interface_time']
                })
            
            result = registry_service.mark_ignored_batch(
                db_path=db_path,
                wal=wal,
                task_keys=task_keys,
                ignored_by=self.user_name,
                ignored_reason=reason
            )
            
            # éšè—å¤„ç†ä¸­æç¤º
            processing_label.destroy()
            
            # æ˜¾ç¤ºç»“æœ
            success_count = result['success_count']
            failed_tasks = result['failed_tasks']
            
            if success_count > 0:
                msg = f"æˆåŠŸå¿½ç•¥ {success_count} ä¸ªå»¶æœŸä»»åŠ¡"
                if failed_tasks:
                    msg += f"\n\nå¤±è´¥ {len(failed_tasks)} ä¸ªä»»åŠ¡ï¼š\n"
                    msg += "\n".join([
                        f"- {t['interface_id']}: {t['reason']}" 
                        for t in failed_tasks[:5]
                    ])
                    if len(failed_tasks) > 5:
                        msg += f"\n... ç­‰å…±{len(failed_tasks)}ä¸ªå¤±è´¥"
                
                messagebox.showinfo("å¿½ç•¥ç»“æœ", msg, parent=self)
                
                if not failed_tasks:
                    self.ignore_successful = True
                    self.destroy()
            else:
                messagebox.showerror("å¤±è´¥", "æ‰€æœ‰ä»»åŠ¡å¿½ç•¥å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°æ—¥å¿—", parent=self)
                
        except Exception as e:
            processing_label.destroy()
            messagebox.showerror("é”™è¯¯", f"å¿½ç•¥è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼š\n{str(e)}", parent=self)
            import traceback
            traceback.print_exc()
```

---

#### 3.3 ä¿®æ”¹ï¼šbase.py - æ·»åŠ æŒ‰é’®å¤„ç†å‡½æ•°

**æ–‡ä»¶**: `base.py`

```python
def _on_ignore_overdue_button_click(self):
    """å¿½ç•¥å»¶æœŸé¡¹æŒ‰é’®ç‚¹å‡»"""
    try:
        # 1. æ£€æŸ¥æ˜¯å¦æ˜¯æ‰€é¢†å¯¼è§’è‰²
        if not self.current_user_role or 'æ‰€é¢†å¯¼' not in self.current_user_role:
            messagebox.showwarning("æƒé™ä¸è¶³", "åªæœ‰æ‰€é¢†å¯¼è§’è‰²å¯ä»¥ä½¿ç”¨æ­¤åŠŸèƒ½", parent=self.root)
            return
        
        # 2. æ”¶é›†æ‰€æœ‰å·²å»¶æœŸçš„ä»»åŠ¡
        overdue_tasks = self._collect_overdue_tasks()
        
        if not overdue_tasks:
            messagebox.showinfo("æç¤º", "å½“å‰æ²¡æœ‰å·²å»¶æœŸçš„ä»»åŠ¡", parent=self.root)
            return
        
        # 3. æ˜¾ç¤ºæ‰¹é‡å¿½ç•¥å¯¹è¯æ¡†
        from ignore_overdue_dialog import IgnoreOverdueDialog
        
        dialog = IgnoreOverdueDialog(
            self.root,
            overdue_tasks,
            self.current_user_name
        )
        dialog.wait_window()
        
        # 4. å¦‚æœæˆåŠŸå¿½ç•¥ï¼Œåˆ·æ–°æ˜¾ç¤º
        if hasattr(dialog, 'ignore_successful') and dialog.ignore_successful:
            try:
                print("[å¿½ç•¥å»¶æœŸ] å¼€å§‹åˆ·æ–°æ˜¾ç¤º...")
                # æ¸…é™¤æ–‡ä»¶ç¼“å­˜
                self.file_manager.clear_file_caches_only()
                # é‡æ–°å¤„ç†æ•°æ®
                self.start_processing()
                print("[å¿½ç•¥å»¶æœŸ] åˆ·æ–°å®Œæˆ")
                
            except Exception as e:
                print(f"[å¿½ç•¥å»¶æœŸ] åˆ·æ–°æ˜¾ç¤ºå¤±è´¥: {e}")
                import traceback
                traceback.print_exc()
        else:
            print("[å¿½ç•¥å»¶æœŸ] ç”¨æˆ·å–æ¶ˆæˆ–æœªå®Œæˆæ“ä½œ")
            
    except Exception as e:
        print(f"å¿½ç•¥å»¶æœŸä»»åŠ¡å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()


def _collect_overdue_tasks(self) -> List[Dict[str, Any]]:
    """
    æ”¶é›†å½“å‰æ‰€æœ‰å·²å»¶æœŸçš„ä»»åŠ¡
    
    è¿”å›:
        List[Dict]: å»¶æœŸä»»åŠ¡åˆ—è¡¨
    """
    from date_utils import is_date_overdue
    
    overdue_tasks = []
    
    # éå†æ‰€æœ‰é€‰é¡¹å¡çš„æ•°æ®
    for tab_name, viewer in self.viewers.items():
        if tab_name == "å§“åè§’è‰²å¯¹åº”è¡¨":
            continue
        
        # è·å–è¯¥é€‰é¡¹å¡çš„åŸå§‹æ•°æ®
        if not hasattr(self, '_tab_data_cache'):
            continue
        
        cache = self._tab_data_cache.get(tab_name)
        if not cache:
            continue
        
        df = cache.get('filtered_df')
        if df is None or df.empty:
            continue
        
        # æ£€æŸ¥æ¯ä¸€è¡Œæ˜¯å¦å»¶æœŸ
        for idx in range(len(df)):
            try:
                row = df.iloc[idx]
                
                # è·å–æ¥å£æ—¶é—´
                interface_time = row.get('æ¥å£æ—¶é—´', '')
                if not interface_time or interface_time == '-':
                    continue
                
                # åˆ¤æ–­æ˜¯å¦å»¶æœŸ
                if not is_date_overdue(str(interface_time)):
                    continue
                
                # æ„å»ºä»»åŠ¡ä¿¡æ¯
                task = {
                    'file_type': cache['file_type'],
                    'project_id': row.get('é¡¹ç›®å·', ''),
                    'interface_id': row.get('æ¥å£å·', ''),
                    'source_file': row.get('_source_file', ''),
                    'row_index': row.get('_original_row', idx + 2),
                    'interface_time': str(interface_time),
                    'status': row.get('çŠ¶æ€', 'å·²å»¶æœŸ')
                }
                
                overdue_tasks.append(task)
                
            except Exception as e:
                print(f"[æ”¶é›†å»¶æœŸä»»åŠ¡] å¤„ç†è¡Œ{idx}å¤±è´¥: {e}")
                continue
    
    print(f"[æ”¶é›†å»¶æœŸä»»åŠ¡] å…±æ‰¾åˆ° {len(overdue_tasks)} ä¸ªå»¶æœŸä»»åŠ¡")
    return overdue_tasks
```

---

### 4. æ˜¾ç¤ºè¿‡æ»¤ä¿®æ”¹

#### 4.1 ä¿®æ”¹ï¼šbase.py - _exclude_pending_confirmation_rows

**æ–‡ä»¶**: `base.py`

**ä½ç½®**: `_exclude_pending_confirmation_rows`æ–¹æ³•ä¸­

```python
def _exclude_pending_confirmation_rows(self, df, status_map, user_roles):
    """
    æ ¹æ®ç”¨æˆ·è§’è‰²è¿‡æ»¤æ‰ä¸åº”è¯¥æ˜¾ç¤ºçš„ä»»åŠ¡
    
    ã€æ–°å¢ã€‘åŒæ—¶è¿‡æ»¤æ‰è¢«å¿½ç•¥çš„ä»»åŠ¡ï¼ˆignored=1ï¼‰
    """
    # ... ç°æœ‰è¿‡æ»¤é€»è¾‘ ...
    
    # ã€æ–°å¢ã€‘è¿‡æ»¤è¢«å¿½ç•¥çš„ä»»åŠ¡ï¼ˆæ‰€æœ‰è§’è‰²éƒ½ä¸æ˜¾ç¤ºï¼‰
    for tid, status_text in status_map.items():
        # å¦‚æœstatus_textä¸ºç©ºå­—ç¬¦ä¸²ï¼Œå¯èƒ½æ˜¯è¢«å¿½ç•¥æˆ–å·²å½’æ¡£çš„ä»»åŠ¡
        # éœ€è¦è¿›ä¸€æ­¥æŸ¥è¯¢ç¡®è®¤
        if not status_text and tid in df_index_map:
            exclude_indices.append(df_index_map[tid])
    
    # ... è¿”å›è¿‡æ»¤åçš„df ...
```

**è¯´æ˜**: åœ¨`get_display_status`ä¸­ï¼Œè¢«å¿½ç•¥çš„ä»»åŠ¡ä¼šè¿”å›ç©ºå­—ç¬¦ä¸²`''`ï¼Œå› æ­¤ä¼šè¢«è¿‡æ»¤æ‰ã€‚

---

### 5. å¯¼å‡ºè¿‡æ»¤ä¿®æ”¹

**æ–‡ä»¶**: `base.py`

**ä½ç½®**: å¯¼å‡ºé€»è¾‘ä¸­ï¼Œä¸`_exclude_pending_confirmation_rows`ä¿æŒä¸€è‡´

å·²é€šè¿‡`_exclude_pending_confirmation_rows`ç»Ÿä¸€å¤„ç†ï¼Œæ— éœ€é¢å¤–ä¿®æ”¹ã€‚

---

### 6. æ•°æ®åº“è¿ç§»

#### 6.1 ä¿®æ”¹ï¼šregistry/db.py

**æ·»åŠ æ–°å­—æ®µå®šä¹‰**

```python
def init_db(conn: sqlite3.Connection) -> None:
    """åˆå§‹åŒ–æ•°æ®åº“è¡¨ç»“æ„"""
    conn.execute("""
        CREATE TABLE IF NOT EXISTS tasks (
            id TEXT PRIMARY KEY,
            ...
            ignored INTEGER DEFAULT 0,
            ignored_at TEXT DEFAULT NULL,
            ignored_by TEXT DEFAULT NULL,
            interface_time_when_ignored TEXT DEFAULT NULL,
            ignored_reason TEXT DEFAULT NULL,
            ...
        );
    """)
    
    # æ·»åŠ ç´¢å¼•
    conn.execute("""
        CREATE INDEX IF NOT EXISTS idx_tasks_ignored ON tasks(ignored, status);
    """)
```

---

#### 6.2 ä¿®æ”¹ï¼šregistry/migrate.py

**æ·»åŠ è¿ç§»é€»è¾‘**

```python
def migrate_database(db_path: str) -> None:
    """æ•°æ®åº“è¿ç§»"""
    conn = sqlite3.connect(db_path)
    
    new_columns = [
        # ... ç°æœ‰åˆ— ...
        ("ignored", "INTEGER DEFAULT 0"),
        ("ignored_at", "TEXT DEFAULT NULL"),
        ("ignored_by", "TEXT DEFAULT NULL"),
        ("interface_time_when_ignored", "TEXT DEFAULT NULL"),
        ("ignored_reason", "TEXT DEFAULT NULL")
    ]
    
    # ... æ·»åŠ åˆ—çš„é€»è¾‘ ...
    
    # æ·»åŠ ç´¢å¼•
    try:
        conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_tasks_ignored ON tasks(ignored, status);
        """)
        print("[è¿ç§»] å·²æ·»åŠ  idx_tasks_ignored ç´¢å¼•")
    except Exception as e:
        print(f"[è¿ç§»] æ·»åŠ ç´¢å¼•å¤±è´¥ï¼ˆå¯èƒ½å·²å­˜åœ¨ï¼‰: {e}")
```

---

### 7. æµ‹è¯•ç”¨ä¾‹è®¾è®¡

#### 7.1 å•å…ƒæµ‹è¯•

**æ–‡ä»¶**: `tests/test_registry_ignore_overdue.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Registryå¿½ç•¥å»¶æœŸä»»åŠ¡åŠŸèƒ½æµ‹è¯•
"""

import pytest
import os
import sqlite3
from datetime import datetime
from registry import service as registry_service
from registry.util import make_task_id, make_business_id
from registry import hooks as registry_hooks


def test_mark_ignored_single_task(temp_db_path):
    """æµ‹è¯•ï¼šæ ‡è®°å•ä¸ªä»»åŠ¡ä¸ºå¿½ç•¥"""
    # 1. åˆ›å»ºä»»åŠ¡
    registry_hooks.set_data_folder(os.path.dirname(temp_db_path))
    
    # ... åˆ›å»ºä¸€ä¸ªå»¶æœŸä»»åŠ¡ ...
    
    # 2. æ ‡è®°ä¸ºå¿½ç•¥
    task_keys = [{
        'file_type': 1,
        'project_id': '1818',
        'interface_id': 'TEST-001',
        'source_file': 'test.xlsx',
        'row_index': 2,
        'interface_time': '2024.01.15'  # å»¶æœŸæ—¶é—´
    }]
    
    result = registry_service.mark_ignored_batch(
        db_path=temp_db_path,
        wal=False,
        task_keys=task_keys,
        ignored_by='æµ‹è¯•æ‰€é¢†å¯¼',
        ignored_reason='æµ‹è¯•å¿½ç•¥'
    )
    
    # 3. éªŒè¯
    assert result['success_count'] == 1
    assert len(result['failed_tasks']) == 0
    
    # 4. æŸ¥è¯¢æ•°æ®åº“ç¡®è®¤
    conn = sqlite3.connect(temp_db_path)
    tid = make_task_id(1, '1818', 'TEST-001', 'test.xlsx', 2)
    cursor = conn.execute(
        "SELECT ignored, ignored_by, ignored_reason, interface_time_when_ignored FROM tasks WHERE id = ?",
        (tid,)
    )
    row = cursor.fetchone()
    
    assert row is not None
    assert row[0] == 1  # ignored
    assert row[1] == 'æµ‹è¯•æ‰€é¢†å¯¼'  # ignored_by
    assert row[2] == 'æµ‹è¯•å¿½ç•¥'  # ignored_reason
    assert row[3] == '2024.01.15'  # interface_time_when_ignored


def test_auto_unignore_on_time_change(temp_db_path):
    """æµ‹è¯•ï¼šé¢„æœŸæ—¶é—´å˜åŒ–æ—¶è‡ªåŠ¨å–æ¶ˆå¿½ç•¥"""
    # 1. åˆ›å»ºå¹¶å¿½ç•¥ä»»åŠ¡
    # ... (åŒä¸Š)
    
    # 2. æ¨¡æ‹Ÿé¢„æœŸæ—¶é—´å˜åŒ–ï¼ˆæ‰«ææ—¶æ›´æ–°ï¼‰
    registry_hooks.on_process_done(
        file_type=1,
        project_id='1818',
        source_file='test.xlsx',
        result_df=pd.DataFrame({
            'åŸå§‹è¡Œå·': [2],
            'æ¥å£å·': ['TEST-001'],
            'é¡¹ç›®å·': ['1818'],
            'æ¥å£æ—¶é—´': ['2026.01.15']  # æ—¶é—´å˜åŒ–ï¼
        }),
        now=datetime.now()
    )
    
    # 3. éªŒè¯å¿½ç•¥å·²å–æ¶ˆ
    conn = sqlite3.connect(temp_db_path)
    tid = make_task_id(1, '1818', 'TEST-001', 'test.xlsx', 2)
    cursor = conn.execute(
        "SELECT ignored FROM tasks WHERE id = ?",
        (tid,)
    )
    row = cursor.fetchone()
    
    assert row is not None
    assert row[0] == 0  # ignoredåº”è¯¥å˜ä¸º0


def test_ignored_task_not_displayed(temp_db_path):
    """æµ‹è¯•ï¼šè¢«å¿½ç•¥çš„ä»»åŠ¡ä¸åœ¨æ˜¾ç¤ºçŠ¶æ€ä¸­è¿”å›"""
    # 1. åˆ›å»ºå¹¶å¿½ç•¥ä»»åŠ¡
    # ...
    
    # 2. æŸ¥è¯¢æ˜¾ç¤ºçŠ¶æ€
    task_keys = [{
        'file_type': 1,
        'project_id': '1818',
        'interface_id': 'TEST-001',
        'source_file': 'test.xlsx',
        'row_index': 2,
        'interface_time': '2024.01.15'
    }]
    
    status_map = registry_hooks.get_display_status(task_keys, "è®¾è®¡äººå‘˜")
    
    # 3. éªŒè¯
    tid = make_task_id(1, '1818', 'TEST-001', 'test.xlsx', 2)
    assert status_map[tid] == ''  # åº”è¿”å›ç©ºå­—ç¬¦ä¸²


def test_batch_ignore_multiple_tasks(temp_db_path):
    """æµ‹è¯•ï¼šæ‰¹é‡å¿½ç•¥å¤šä¸ªä»»åŠ¡"""
    # åˆ›å»º10ä¸ªå»¶æœŸä»»åŠ¡ï¼Œæ‰¹é‡å¿½ç•¥
    # ...


def test_cannot_ignore_non_overdue_task(temp_db_path):
    """æµ‹è¯•ï¼šä¸èƒ½å¿½ç•¥æœªå»¶æœŸçš„ä»»åŠ¡ï¼ˆå¯é€‰é€»è¾‘ï¼‰"""
    # åˆ›å»ºæœªå»¶æœŸä»»åŠ¡ï¼Œå°è¯•å¿½ç•¥ï¼Œåº”è¯¥è¢«æ‹’ç»æˆ–å‘å‡ºè­¦å‘Š
    # ...
```

---

#### 7.2 é›†æˆæµ‹è¯•

**æµ‹è¯•å®Œæ•´å·¥ä½œæµ**ï¼š
1. æ‰€é¢†å¯¼ç™»å½•
2. ç‚¹å‡»"å¿½ç•¥å»¶æœŸé¡¹"æŒ‰é’®
3. åœ¨å¼¹çª—ä¸­é€‰æ‹©ä»»åŠ¡å¹¶å¿½ç•¥
4. éªŒè¯ä¸»æ˜¾ç¤ºä¸­ä¸å†æ˜¾ç¤ºè¿™äº›ä»»åŠ¡
5. æ¨¡æ‹Ÿé¢„æœŸæ—¶é—´å˜åŒ–
6. éªŒè¯ä»»åŠ¡é‡æ–°å‡ºç°

---

## ğŸ“Š å®æ–½è®¡åˆ’

### é˜¶æ®µ1ï¼šæ•°æ®åº“å’ŒæœåŠ¡å±‚ï¼ˆ40%å·¥ä½œé‡ï¼‰

1. âœ… ä¿®æ”¹æ•°æ®åº“schemaï¼ˆ`registry/db.py`ï¼‰
2. âœ… æ·»åŠ è¿ç§»é€»è¾‘ï¼ˆ`registry/migrate.py`ï¼‰
3. âœ… å®ç°`mark_ignored_batch`å‡½æ•°
4. âœ… å®ç°`check_and_auto_unignore`å‡½æ•°
5. âœ… ä¿®æ”¹`upsert_task`æ·»åŠ è‡ªåŠ¨å–æ¶ˆå¿½ç•¥æ£€æµ‹
6. âœ… ä¿®æ”¹`get_display_status`è¿‡æ»¤è¢«å¿½ç•¥ä»»åŠ¡

**é¢„è®¡Token**: 2-3ä¸‡

---

### é˜¶æ®µ2ï¼šUIå±‚ï¼ˆ40%å·¥ä½œé‡ï¼‰

1. âœ… åˆ›å»º`IgnoreOverdueDialog`å¯¹è¯æ¡†
2. âœ… åœ¨`base.py`ä¸­æ·»åŠ "å¿½ç•¥å»¶æœŸé¡¹"æŒ‰é’®
3. âœ… å®ç°`_on_ignore_overdue_button_click`å¤„ç†å‡½æ•°
4. âœ… å®ç°`_collect_overdue_tasks`æ”¶é›†å‡½æ•°
5. âœ… ä¿®æ”¹`_exclude_pending_confirmation_rows`è¿‡æ»¤é€»è¾‘

**é¢„è®¡Token**: 2-3ä¸‡

---

### é˜¶æ®µ3ï¼šæµ‹è¯•ï¼ˆ20%å·¥ä½œé‡ï¼‰

1. âœ… ç¼–å†™å•å…ƒæµ‹è¯•
2. âœ… ç¼–å†™é›†æˆæµ‹è¯•
3. âœ… æ‰‹åŠ¨æµ‹è¯•å®Œæ•´æµç¨‹

**é¢„è®¡Token**: 1-2ä¸‡

---

### æ€»è®¡

**é¢„è®¡Token**: 5-8ä¸‡  
**é¢„è®¡æ—¶é—´**: 2-3å°æ—¶  
**å¤æ‚åº¦**: ä¸­ç­‰

---

## ğŸ¯ å…³é”®æŠ€æœ¯ç‚¹

### 1. å»¶æœŸåˆ¤æ–­å¤ç”¨

ä½¿ç”¨ç°æœ‰çš„`is_date_overdue`å‡½æ•°ï¼ˆ`date_utils.py`ï¼‰ï¼Œæ— éœ€é‡æ–°å®ç°ã€‚

---

### 2. ä¸šåŠ¡IDæŸ¥è¯¢

ä½¿ç”¨`business_id`æŸ¥è¯¢æœ€æ–°éå½’æ¡£ä»»åŠ¡ï¼Œç¡®ä¿ç‰ˆæœ¬åŒ–åä»èƒ½æ­£ç¡®æ“ä½œã€‚

---

### 3. æ—¶é—´å˜åŒ–æ£€æµ‹

åœ¨`upsert_task`ä¸­æ¯”è¾ƒ`interface_time_when_ignored`å’Œå½“å‰`interface_time`ï¼Œè‡ªåŠ¨å–æ¶ˆå¿½ç•¥ã€‚

---

### 4. æ˜¾ç¤ºè¿‡æ»¤ç»Ÿä¸€

é€šè¿‡`get_display_status`è¿”å›ç©ºå­—ç¬¦ä¸²çš„æ–¹å¼ï¼Œç»Ÿä¸€å¤„ç†æ˜¾ç¤ºå’Œå¯¼å‡ºè¿‡æ»¤ã€‚

---

### 5. UIå¤ç”¨

å‚è€ƒ`AssignmentDialog`çš„è®¾è®¡ï¼Œä¿æŒUIé£æ ¼ä¸€è‡´ã€‚

---

## âš ï¸ æ³¨æ„äº‹é¡¹

### 1. æƒé™æ§åˆ¶

- **ä¸¥æ ¼æ£€æŸ¥**ï¼šåªæœ‰"æ‰€é¢†å¯¼"è§’è‰²å¯ä»¥æ‰§è¡Œå¿½ç•¥æ“ä½œ
- åœ¨UIæŒ‰é’®å’Œå¯¹è¯æ¡†ä¸­åŒé‡éªŒè¯

---

### 2. æ•°æ®ä¸€è‡´æ€§

- å¿½ç•¥æ“ä½œä¸å½±å“Excelæºæ–‡ä»¶
- ä»…åœ¨Registryæ•°æ®åº“ä¸­æ ‡è®°
- é¢„æœŸæ—¶é—´å˜åŒ–æ—¶è‡ªåŠ¨æ¢å¤æ˜¾ç¤º

---

### 3. ç”¨æˆ·ä½“éªŒ

- æä¾›é¢„è®¾å¿½ç•¥åŸå› ï¼Œæ–¹ä¾¿å¿«é€Ÿæ“ä½œ
- æ”¯æŒè‡ªå®šä¹‰åŸå› è¾“å…¥
- äºŒæ¬¡ç¡®è®¤ï¼Œé˜²æ­¢è¯¯æ“ä½œ
- æ¸…æ™°çš„æ“ä½œåé¦ˆ

---

### 4. å‘åå…¼å®¹

- æ—§æ•°æ®åº“è‡ªåŠ¨è¿ç§»
- æ–°å¢å­—æ®µæœ‰é»˜è®¤å€¼
- ä¸å½±å“ç°æœ‰åŠŸèƒ½

---

## ğŸ” æ½œåœ¨æ‰©å±•

### å¯é€‰åŠŸèƒ½ï¼ˆæš‚ä¸å®æ–½ï¼‰

1. **æŸ¥çœ‹å·²å¿½ç•¥ä»»åŠ¡åˆ—è¡¨**
   - å•ç‹¬çš„"å·²å¿½ç•¥ä»»åŠ¡"è§†å›¾
   - æ”¯æŒæ‰‹åŠ¨å–æ¶ˆå¿½ç•¥

2. **å¿½ç•¥ç»Ÿè®¡æŠ¥è¡¨**
   - ç»Ÿè®¡å„æ—¶é—´æ®µå¿½ç•¥çš„ä»»åŠ¡æ•°é‡
   - åˆ†æé•¿æœŸå»¶æœŸåŸå› 

3. **è‡ªåŠ¨å¿½ç•¥è§„åˆ™**
   - è¶…æœŸXå¤©è‡ªåŠ¨å»ºè®®å¿½ç•¥
   - æ™ºèƒ½æ¨èå¿½ç•¥åŸå› 

---

## âœ… æ€»ç»“

æœ¬è®¾è®¡æ–¹æ¡ˆæä¾›äº†ä¸€ä¸ª**å®Œæ•´ã€å¯é ã€æ˜“ç”¨**çš„æ‰¹é‡å¿½ç•¥å»¶æœŸä»»åŠ¡åŠŸèƒ½ï¼š

- âœ… **æ•°æ®å±‚**ï¼šå®Œæ•´çš„schemaè®¾è®¡å’Œè¿ç§»é€»è¾‘
- âœ… **æœåŠ¡å±‚**ï¼šæ‰¹é‡æ“ä½œã€è‡ªåŠ¨å–æ¶ˆå¿½ç•¥ã€æ˜¾ç¤ºè¿‡æ»¤
- âœ… **UIå±‚**ï¼šå‹å¥½çš„æ‰¹é‡æ“ä½œå¯¹è¯æ¡†ã€æƒé™æ§åˆ¶
- âœ… **æµ‹è¯•**ï¼šå®Œå–„çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
- âœ… **ç”¨æˆ·ä½“éªŒ**ï¼šç±»ä¼¼ç°æœ‰"è¯·æŒ‡æ´¾"åŠŸèƒ½ï¼Œå­¦ä¹ æˆæœ¬ä½

---

**è¯·æ‚¨å®¡é˜…æ­¤è®¾è®¡æ–¹æ¡ˆï¼Œç¡®è®¤åæˆ‘å°†å¼€å§‹å®æ–½ï¼**

æœ‰ä»»ä½•éœ€è¦è°ƒæ•´çš„åœ°æ–¹ï¼Œè¯·å‘Šè¯‰æˆ‘ã€‚ğŸ¤”

