# 勾选框Registry化与多接口号支持 - 需求分析

**日期**: 2025-11-11  
**状态**: 📋 待确认  
**优先级**: P1

---

## 📝 需求概述

用户提出5点需求，核心目标：
1. 将勾选框状态从缓存转移到Registry数据库
2. 增加完成人/确认人字段
3. 实现基于Registry的勾选框逻辑和权限控制
4. 支持多接口号（逗号分隔）的识别和存储
5. 先确认方案再执行

---

## 🎯 需求详细分析

### 需求1：勾选框与Registry关联

**当前问题**：
- 勾选框状态可能与缓存深度捆绑
- 不符合"中心登记簿"理念

**期望**：
- 勾选框状态完全由Registry管理
- 与缓存解绑

**影响范围**：
- `window.py`：勾选框状态读取逻辑
- `base.py`：可能涉及`completed_rows`相关逻辑

---

### 需求2：数据库增加字段

**新增字段**：

| 位置 | 新字段 | 类型 | 说明 |
|------|-------|------|------|
| `completed_at`后 | `completed_by` | TEXT | 完成人（填写回文单号的人员姓名） |
| `confirmed_at`后 | `confirmed_by` | TEXT | 确认人（勾选确认的上级人员姓名） |

**数据来源**：
- `completed_by`：填写回文单号时，从当前登录用户获取姓名
- `confirmed_by`：上级勾选确认时，从当前登录用户获取姓名

**涉及文件**：
- `registry/migrate.py`：迁移脚本
- `registry/db.py`：schema定义
- `registry/service.py`：upsert逻辑
- `registry/hooks.py`：钩子函数写入逻辑

---

### 需求3：重写勾选框逻辑

#### 3.1 设计人员角色

**场景1：未完成**
```
Registry记录：
  completed_by = NULL
  
显示：
  勾选框：☐ 未勾选
  
行为：
  - 可以填写回文单号
  - 填写后 → completed_by = 当前用户姓名
```

**场景2：已完成（自己完成）**
```
Registry记录：
  completed_by = "张三"
  当前登录用户 = "张三"
  
显示：
  勾选框：☑ 已勾选
  
行为：
  - 可以取消勾选？（待确认）
  - 或者只读？
```

**场景3：已完成（其他人完成）**
```
Registry记录：
  completed_by = "李四"
  当前登录用户 = "张三"
  
显示：
  勾选框：☑ 已勾选（灰色？只读？）
  
行为：
  - 只读，不能取消
```

**❓ 待确认**：
- 设计人员能否取消自己的完成状态？
- 答复：可以取消，同时我在这里补充一下，有时上级角色也会自行完成填入回文单号，所以比如室主任角色或者接口工程师或者所领导填入回文单后，就自动完成确认即可，无须再次由自己或其他上级角色再次确认了。

- 设计人员能否看到其他人完成的接口？（根据角色筛选可能看不到）
- 答复：看不到，自然也就不能修改。

---

#### 3.2 上级角色（室主任、所领导）

**场景1：设计人员已完成，待确认**
```
Registry记录：
  completed_by = "张三"（设计人员）
  confirmed_by = NULL
  
显示：
  所有上级角色：
    勾选框：☐ 未勾选
    状态：待审查
  
行为：
  - 任一上级可以勾选
  - 勾选后 → confirmed_by = 当前上级姓名
```

**场景2：已确认（自己确认）**
```
Registry记录：
  completed_by = "张三"
  confirmed_by = "王主任"
  当前登录用户 = "王主任"
  
显示：
  勾选框：☑ 已勾选
  
行为：
  - 可以取消勾选
  - 取消后 → confirmed_by = NULL
```

**场景3：已确认（其他上级确认）**
```
Registry记录：
  completed_by = "张三"
  confirmed_by = "王主任"
  当前登录用户 = "李主任"
  
显示：
  勾选框：☑ 已勾选（只读）
  
行为：
  - 尝试勾选 → 弹窗："该接口已由王主任确认"
  - 不能取消，不能重复确认
```

**❓ 待确认**：
- 确认后，状态应该变为什么？"已完成"？还是保持"待审查"？
- 答复："已完成"
- 确认后，是否从上级的显示列表中消失？
- 答复：消失

---

### 需求4：多接口号支持

#### 4.1 场景描述

**现状**：
```
Excel某行：
  接口号列 = "EDMB-701775-ECZB,EDMB-701738-EXWB"
  （逗号分隔，可能更多）
  
当前处理：
  作为一个整体存储
  interface_id = "EDMB-701775-ECZB,EDMB-701738-EXWB"
```

**期望**：
```
识别为2个独立接口号：
  1. EDMB-701775-ECZB
  2. EDMB-701738-EXWB
  
分别存储完成/确认信息：
  Registry记录1：
    interface_id = "EDMB-701775-ECZB"
    completed_by = "张三"
    
  Registry记录2：
    interface_id = "EDMB-701738-EXWB"
    completed_by = "张三"
```

---

#### 4.2 数据存储策略（我的建议）

**方案A：拆分存储（推荐）** ⭐

**处理时机**：在`main.py`处理Excel数据时拆分

```python
# 原始数据
row = {
    '项目号': '2016',
    '接口号': 'EDMB-701775-ECZB,EDMB-701738-EXWB',
    '接口时间': '2025-01-15',
    # ... 其他列
}

# 拆分后
row1 = {
    '项目号': '2016',
    '接口号': 'EDMB-701775-ECZB',  # 拆分1
    '接口时间': '2025-01-15',
    # ... 其他列相同
}

row2 = {
    '项目号': '2016',
    '接口号': 'EDMB-701738-EXWB',  # 拆分2
    '接口时间': '2025-01-15',
    # ... 其他列相同
}

# DataFrame中变成2行
```

**business_id**：
```
business_id1 = "6_2016_EDMB-701775-ECZB"
business_id2 = "6_2016_EDMB-701738-EXWB"
```

**优点**：
- ✅ 每个接口号历史清晰
- ✅ 查询简单
- ✅ 支持单个接口独立出现后的状态延续

**缺点**：
- ⚠️ 主显示窗会显示多行（同一Excel行拆成多个接口行）
- ⚠️ Excel写入时需要特殊处理（写一次，但更新多条Registry记录）

---

**方案B：保持原格式 + 添加原始接口号字段（备选）**

```python
# Registry记录
{
    'interface_id': 'EDMB-701775-ECZB,EDMB-701738-EXWB',  # 原始格式
    'original_interface_ids': 'EDMB-701775-ECZB,EDMB-701738-EXWB',  # 用于查询
    'completed_by': '张三'
}

# 查询时拆分
interface_ids = original_interface_ids.split(',')
```

**优点**：
- ✅ 保持Excel数据完整性
- ✅ 主显示窗不会多行

**缺点**：
- ❌ 单个接口号独立出现时，历史断裂
- ❌ 查询复杂（需要LIKE或全文检索）

---

**❓ 待确认**：您倾向哪个方案？

我的建议是**方案A（拆分存储）**，因为：
1. 符合"每个接口号独立追踪"的理念
2. 支持您说的"某次联合出现后，可能还会出现独立出现"的情况
3. 查询简单，逻辑清晰

---

#### 4.3 查询支持

**单个查询**：
```
用户输入："EDMB-701775-ECZB"

SQL: SELECT * FROM tasks WHERE interface_id = 'EDMB-701775-ECZB'

结果：
  - 2025-01-15：与EDMB-701738-EXWB联合出现（如果有）
  - 2025-02-10：独立出现（如果有）
```

**组合查询**：
```
用户输入："EDMB-701775-ECZB,EDMB-701738-EXWB"

处理：先拆分为 ['EDMB-701775-ECZB', 'EDMB-701738-EXWB']

SQL: 
SELECT * FROM tasks 
WHERE interface_id IN ('EDMB-701775-ECZB', 'EDMB-701738-EXWB')
ORDER BY last_seen_at DESC

结果：显示两个接口号的所有历史记录
```

---

#### 4.4 Excel写入处理

**场景**：
```
用户点击接口号："EDMB-701775-ECZB,EDMB-701738-EXWB"（主显示窗第5行）
填写回文单号："HF-2025-001"
```

**处理流程**：
```python
# 1. 识别多接口号
interface_ids = "EDMB-701775-ECZB,EDMB-701738-EXWB".split(',')
# = ['EDMB-701775-ECZB', 'EDMB-701738-EXWB']

# 2. Excel写入（只写一次，因为是同一行）
write_to_excel(
    file_path=source_file,
    row_index=87,
    response_number="HF-2025-001"
)

# 3. Registry更新（更新多条记录）
for interface_id in interface_ids:
    registry_hooks.on_response_written(
        key={
            'file_type': 6,
            'project_id': '2016',
            'interface_id': interface_id.strip(),  # 单个接口号
            # ...
        },
        response_number="HF-2025-001",
        completed_by="张三"  # 当前用户
    )
```

---

#### 4.5 主显示窗显示

**如果采用方案A（拆分存储）**：

```
主显示窗（收发文函）：
┌───────┬───────────┬────────────────────┬─────────┬──────┐
│ 行号  │ 项目号    │ 接口号              │ 状态    │ 勾选 │
├───────┼───────────┼────────────────────┼─────────┼──────┤
│ 87    │ 2016      │ EDMB-701775-ECZB   │ 待完成  │ ☐   │  ← 拆分后的第1行
│ 87    │ 2016      │ EDMB-701738-EXWB   │ 待完成  │ ☐   │  ← 拆分后的第2行
└───────┴───────────┴────────────────────┴─────────┴──────┘
```

**注意**：
- 两行的"行号"都是87（因为在Excel中是同一行）
- 但接口号不同，是独立的两个任务

**❓ 待确认**：您接受这种显示方式吗？

---

### 需求5：整体思路确认

（见本文档汇总）

---

## 🛠️ 技术实现方案

### 1. 数据库迁移

**文件**: `registry/migrate.py`

```python
new_columns = [
    # ... existing columns ...
    ("completed_by", "TEXT DEFAULT NULL"),  # 完成人
    ("confirmed_by", "TEXT DEFAULT NULL"),  # 确认人（原来叫confirmed_by，现在是确认人姓名）
]
```

**注意**：原来的`confirmed_by`字段存储的是"所长"等角色名，现在改为存储人员姓名，需要考虑兼容性。

**❓ 待确认**：
- 原来的`confirmed_by`字段要重命名吗？比如`confirmed_by_role`？
- 还是直接覆盖？（可能丢失历史数据）

---

### 2. 多接口号拆分

**文件**: `main.py`

**位置**：在每个`process_target_fileX`函数中，处理`result_df`时

```python
def split_interface_ids(df, interface_column):
    """
    拆分接口号列，如果包含逗号，则拆成多行
    
    参数:
        df: DataFrame
        interface_column: 接口号列名
    
    返回:
        拆分后的DataFrame
    """
    rows = []
    for idx, row in df.iterrows():
        interface_id = str(row[interface_column])
        
        # 检查是否包含逗号
        if ',' in interface_id or '，' in interface_id:  # 支持中英文逗号
            # 拆分
            ids = [id.strip() for id in interface_id.replace('，', ',').split(',')]
            # 为每个接口号创建一行
            for id in ids:
                if id:  # 非空
                    new_row = row.copy()
                    new_row[interface_column] = id
                    rows.append(new_row)
        else:
            # 不需要拆分
            rows.append(row)
    
    return pd.DataFrame(rows).reset_index(drop=True)

# 在每个process_target_fileX中调用
result_df = split_interface_ids(result_df, '接口号')
```

---

### 3. 勾选框状态读取

**文件**: `window.py`

**当前逻辑**（推测）：
```python
# 可能从completed_rows读取
if row_index in completed_rows:
    checkbox_state = '☑'
```

**新逻辑**：
```python
def get_checkbox_state_from_registry(business_id, current_user_name, current_role):
    """
    从Registry读取勾选框状态
    
    返回:
        {
            'checked': True/False,
            'readonly': True/False,
            'message': str  # 如果只读，显示的提示信息
        }
    """
    task = get_task_by_business_id(business_id)
    
    if not task:
        # 无记录
        return {'checked': False, 'readonly': False, 'message': ''}
    
    # 判断角色
    if current_role in ['设计人员', '接口工程师']:
        # 设计人员角色
        if task['completed_by']:
            # 已完成
            return {
                'checked': True,
                'readonly': True,  # 或False，取决于是否允许取消
                'message': f"已由{task['completed_by']}完成"
            }
        else:
            return {'checked': False, 'readonly': False, 'message': ''}
    
    elif current_role in ['一室主任', '二室主任', '建筑总图室主任', '所长', '所领导']:
        # 上级角色
        if task['completed_by'] and not task['confirmed_by']:
            # 已完成，待确认
            return {'checked': False, 'readonly': False, 'message': ''}
        
        elif task['confirmed_by']:
            # 已确认
            if task['confirmed_by'] == current_user_name:
                # 自己确认的
                return {
                    'checked': True,
                    'readonly': False,  # 可以取消
                    'message': ''
                }
            else:
                # 其他人确认的
                return {
                    'checked': True,
                    'readonly': True,
                    'message': f"该接口已由{task['confirmed_by']}确认"
                }
        else:
            # 未完成
            return {'checked': False, 'readonly': True, 'message': '待设计人员完成'}
    
    return {'checked': False, 'readonly': False, 'message': ''}
```

---

### 4. 回文单号写入时传递用户姓名

**文件**: `input_handler.py`

```python
# on_confirm方法中
if registry_hooks:
    registry_hooks.on_response_written(
        key=key,
        response_number=response_number,
        completed_by=self.current_user_name,  # 新增参数
        user_info=self.user_info  # 传递完整用户信息
    )
```

**文件**: `registry/hooks.py`

```python
def on_response_written(..., completed_by=None, user_info=None):
    # ...
    fields_to_update = {
        # ...
        'completed_by': completed_by,  # 新增字段
    }
```

---

### 5. 确认时写入确认人

**文件**: `window.py` 或相关文件

```python
# 上级勾选确认时
if registry_hooks:
    registry_hooks.on_confirmed_by_superior(
        key=key,
        confirmed_by=current_user_name,  # 新增参数
        user_info=user_info
    )
```

**文件**: `registry/hooks.py`

```python
def on_confirmed_by_superior(..., confirmed_by=None, user_info=None):
    # ...
    fields_to_update = {
        # ...
        'confirmed_by': confirmed_by,  # 新增字段
    }
```

---

### 6. 历史查询界面增加列

**文件**: `registry/history_ui.py`

```python
columns = (
    "项目号", "接口号", "状态", "回文单号", 
    "完成人", "完成时间",  # 新增"完成人"
    "确认人", "确认时间",  # 新增"确认人"
    "首次出现", "最近出现"
)
```

---

## 📋 涉及文件清单

| 文件 | 改动内容 | 优先级 |
|------|---------|--------|
| `registry/migrate.py` | 添加`completed_by`、`confirmed_by`迁移 | P0 |
| `registry/db.py` | 更新schema定义 | P0 |
| `registry/service.py` | 更新upsert逻辑，包含新字段 | P0 |
| `registry/hooks.py` | 写入`completed_by`、`confirmed_by` | P0 |
| `main.py` | 拆分多接口号为多行 | P1 |
| `window.py` | 从Registry读取勾选框状态，实现权限控制 | P1 |
| `input_handler.py` | 传递当前用户姓名 | P1 |
| `base.py` | 移除缓存相关的completed_rows逻辑（如果有） | P2 |
| `registry/history_ui.py` | 增加"完成人"、"确认人"列 | P2 |

---

## ❓ 待您确认的问题

### 问题1：设计人员勾选框行为
- **场景**：设计人员填写回文单号后，`completed_by`被记录
- **问题**：设计人员能否看到/取消自己的完成状态？
- **选项**：
  - A：设计人员不显示勾选框（因为完成由填写回文单号触发）
  - B：设计人员显示已勾选，但只读
  - C：设计人员显示已勾选，可以取消

**我的建议**：选项A，因为设计人员的"完成"由填写回文单号触发，勾选框对他们没有意义。

---

### 问题2：多接口号存储方案
- **问题**：`EDMB-701775-ECZB,EDMB-701738-EXWB`如何存储？
- **选项**：
  - A：拆分存储（2条Registry记录），主显示窗显示2行
  - B：保持原格式存储（1条记录），主显示窗显示1行

**我的建议**：选项A（拆分存储），理由见前文。

---

### 问题3：确认后状态变化
- **场景**：上级勾选确认后，`confirmed_by`被写入
- **问题**：
  - 确认后，`display_status`应该变为什么？保持"待审查"？还是"已完成"？
  - 确认后，该接口是否从上级的显示列表中消失？

**我的建议**：
- 状态变为"已完成"
- 从上级显示列表中消失（因为已经审查完成）

---

### 问题4：原有`confirmed_by`字段兼容性
- **问题**：原来的`confirmed_by`存储的是角色（"所长"），现在要存储人员姓名（"王所长"）
- **选项**：
  - A：重命名原字段为`confirmed_by_role`，新增`confirmed_by_name`
  - B：直接覆盖（丢失历史角色信息）
  - C：迁移时转换（将"所长"等角色转为对应人员姓名，但无法准确对应）

**我的建议**：选项A（重命名），保留历史数据。

---

### 问题5：Excel行号显示
- **场景**：Excel第87行包含2个接口号，拆分后主显示窗显示2行
- **问题**：两行的"行号"列都显示"87"，您接受吗？还是需要区分（87-1、87-2）？

**我的建议**：都显示"87"即可，因为确实是同一Excel行。

---

### 问题6：中英文逗号支持
- **问题**：接口号分隔符是中文逗号"，"还是英文逗号","？还是都支持？

**我的建议**：都支持，统一转为英文逗号处理。

---

## 🚀 实施步骤（待确认后执行）

### 第一阶段：数据库改造（P0）
1. 修改`registry/migrate.py`：添加迁移脚本
2. 修改`registry/db.py`：更新schema
3. 修改`registry/service.py`：更新upsert逻辑
4. 测试迁移脚本

### 第二阶段：多接口号支持（P1）
1. 修改`main.py`：实现`split_interface_ids`函数
2. 在所有`process_target_fileX`中调用拆分函数
3. 测试拆分逻辑

### 第三阶段：勾选框Registry化（P1）
1. 修改`registry/hooks.py`：写入`completed_by`、`confirmed_by`
2. 修改`input_handler.py`：传递用户姓名
3. 修改`window.py`：从Registry读取勾选框状态
4. 实现权限控制逻辑（确认人校验）
5. 测试勾选框逻辑

### 第四阶段：UI增强（P2）
1. 修改`registry/history_ui.py`：增加"完成人"、"确认人"列
2. 修改`base.py`：清理缓存相关逻辑
3. 全面测试

### 第五阶段：文档和清理
1. 生成实施报告
2. 清理中间文档

---

## 📊 预期效果

### 用户体验改进
1. ✅ 勾选框状态持久化，不受缓存影响
2. ✅ 多个接口号独立追踪，历史清晰
3. ✅ 确认人权限控制，避免重复确认
4. ✅ 历史查询显示完成人/确认人，责任清晰

### 技术改进
1. ✅ 数据一致性：勾选框状态来自唯一数据源（Registry）
2. ✅ 可追溯性：记录操作人员姓名
3. ✅ 灵活性：支持多接口号的联合/独立场景

---

## ⚠️ 风险提示

1. **主显示窗行数增加**：
   - 拆分接口号后，显示行数会增加
   - 可能影响用户习惯

2. **Excel写入逻辑复杂**：
   - 需要处理"一行Excel，多条Registry记录"的映射
   - 需要仔细测试

3. **历史数据兼容性**：
   - 需要处理原有`confirmed_by`字段的兼容性

---

## 总结

**核心改动**：
1. 🗄️ 数据库增加`completed_by`、`confirmed_by`字段
2. 🔢 支持多接口号拆分存储
3. ☑️ 勾选框状态从Registry读取，实现权限控制
4. 👤 记录操作人员姓名，提高可追溯性

**待确认问题**：6个（见上文❓标记）

---

**请您review本方案，确认后我再开始实施！** 🙏

