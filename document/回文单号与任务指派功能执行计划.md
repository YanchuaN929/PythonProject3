# 回文单号与任务指派功能 - 分步执行计划

> **版本**: 1.0  
> **创建日期**: 2025-10-30  
> **适用对象**: 新AI助手  
> **目标**: 按照本计划逐步实施，确保功能完整且无破坏性

---

## 📋 执行前检查清单

在开始执行前，请确认以下内容：

- [ ] 已阅读 `项目完整文档_AI接手指南.md`
- [ ] 已阅读 `回文单号与任务指派功能需求文档.md`
- [ ] 已运行所有现有测试（247个测试全部通过）
- [ ] 已备份关键文件（`base.py`, `window.py`, `main.py`）
- [ ] 已理解现有代码架构和设计原则
- [ ] 已准备好测试Excel文件

---

## 🎯 执行原则

1. **小步快跑**: 每个阶段完成后立即测试
2. **测试先行**: 先写测试用例，再写功能代码
3. **向后兼容**: 确保现有功能零破坏
4. **充分注释**: 关键逻辑必须注释说明
5. **持续验证**: 每阶段运行全量测试

---

## 📊 执行阶段总览

| 阶段 | 任务 | 预计工作量 | 风险等级 |
|------|------|-----------|---------|
| **阶段1** | 责任人列显示 | 2小时 | 低 |
| **阶段2** | 回文单号输入模块 | 4小时 | 中 |
| **阶段3** | 任务指派模块 | 6小时 | 高 |
| **阶段4** | 指派追踪功能 | 3小时 | 中 |
| **阶段5** | 缓存适配与集成 | 2小时 | 中 |
| **阶段6** | 打包与验收 | 2小时 | 低 |
| **总计** | - | **19小时** | - |

---

## 阶段1: 责任人列显示

### 目标
在主显示窗口新增"责任人"列，显示各文件的责任人信息。

### 前置条件
- 已理解 `main.py` 中各文件的责任人列读取逻辑
- 已理解 `window.py` 的列显示机制

### 执行步骤

#### 步骤1.1: 验证责任人数据是否已提取（5分钟）

**检查点**:
```bash
# 检查各文件的process_target_fileX函数是否已提取责任人
grep -n "责任人" main.py
```

**预期结果**:
- 文件1: 第454-465行，从R列(17)提取
- 文件3: 第1496-1507行，从AP列(41)提取
- 文件4: 第2257-2268行，从AH列(33)提取
- 文件5: 第2846-2857行，从K列(10)提取
- 文件6: 第3230-3243行，从X列(23)提取
- 文件2: **无责任人列**

**操作**: 如果已存在，跳到步骤1.3；如果不存在，执行步骤1.2

#### 步骤1.2: 为文件2添加"责任人"列（10分钟）

**文件**: `main.py`

**位置**: `process_target_file2()` 函数末尾（约第1084行）

**代码**:
```python
# 新增"责任人"列（文件2无责任人列，统一显示"无"）
try:
    result_df['责任人'] = "无"
except Exception:
    result_df['责任人'] = ""
```

**测试**:
```bash
python -c "
from main import process_target_file2
from datetime import datetime
# 使用测试文件
result = process_target_file2('测试文件路径', datetime.now())
print('责任人' in result.columns)
print(result['责任人'].unique())
"
```

#### 步骤1.3: 修改window.py显示逻辑（30分钟）

**文件**: `window.py`

**位置**: `_create_optimized_display()` 方法

**当前列顺序**:
```python
columns = ['状态', '项目号', '接口号', '接口时间', '是否已完成']
```

**修改为**:
```python
columns = ['状态', '项目号', '接口号', '接口时间', '责任人', '是否已完成']
```

**详细修改**:

1. 找到 `_create_optimized_display()` 方法（约第714行）
2. 修改列选择逻辑：

```python
def _create_optimized_display(self, df, tab_name, completed_rows=None):
    """
    创建优化的显示DataFrame（仅显示关键列）
    """
    if df.empty:
        return df
    
    # 定义显示列（添加责任人列）
    display_columns = []
    
    # 1. 状态列（如果存在）
    if '状态' in df.columns:
        display_columns.append('状态')
    
    # 2. 项目号列（如果存在）
    if '项目号' in df.columns:
        display_columns.append('项目号')
    
    # 3. 接口号列（必须）
    interface_col = None
    for col in ['A', 'E', 'C', 'R', '接口号']:
        if col in df.columns:
            interface_col = col
            break
    
    if interface_col:
        display_columns.append(interface_col)
        # 重命名为统一的"接口号"
        if interface_col != '接口号':
            df = df.rename(columns={interface_col: '接口号'})
    
    # 4. 接口时间列（如果存在）
    if '接口时间' in df.columns:
        display_columns.append('接口时间')
    
    # 5. 责任人列（新增，如果存在）
    if '责任人' in df.columns:
        display_columns.append('责任人')
    
    # 6. 是否已完成列（始终添加）
    display_columns.append('是否已完成')
    
    # ... 后续逻辑 ...
```

3. 修改固定列宽配置（约第538行）:

```python
fixed_column_widths = {
    '状态': 50,
    '项目号': 75,
    '接口号': 240,
    '接口时间': 85,
    '责任人': 100,      # 新增
    '是否已完成': 95
}
```

4. 修改列对齐方式（约第570行）:

```python
column_alignment = {
    '状态': 'center',
    '项目号': 'center',
    '接口号': 'w',
    '接口时间': 'center',
    '责任人': 'center',  # 新增
    '是否已完成': 'center'
}
```

#### 步骤1.4: 处理空值显示（10分钟）

**文件**: `window.py`

**位置**: `display_excel_data()` 方法中，接口时间处理后

**添加代码**:
```python
# 【新增】处理"责任人"列：空值显示为"无"
if "责任人" in display_df.columns:
    responsible_values = []
    for idx in range(len(display_df)):
        try:
            responsible_value = display_df.iloc[idx]["责任人"]
            # 空值处理
            if pd.isna(responsible_value) or str(responsible_value).strip() == '':
                resp_str = '无'
            else:
                resp_str = str(responsible_value).strip()
            responsible_values.append(resp_str)
        except Exception:
            responsible_values.append('无')
    
    display_df["责任人"] = responsible_values
```

#### 步骤1.5: 编写测试用例（30分钟）

**文件**: `tests/test_responsible_person_display.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
责任人列显示功能测试
"""

import pytest
import pandas as pd
from main import (
    process_target_file1,
    process_target_file2,
    process_target_file3,
    process_target_file4,
    process_target_file5,
    process_target_file6
)
from datetime import datetime


class TestResponsiblePersonColumn:
    """测试责任人列的存在性和数据正确性"""
    
    def test_file1_has_responsible_column(self):
        """测试文件1有责任人列"""
        # 创建测试DataFrame
        test_data = {
            'H': ['25C1'] * 5,
            'M': [''] * 5,
            'R': ['王任超', '李四', '', None, '张三李四'],  # R列：责任人
        }
        df = pd.DataFrame(test_data)
        
        # 模拟process_target_file1的责任人提取逻辑
        import re
        zh_pattern = re.compile(r"[\u4e00-\u9fa5]+")
        owners = []
        for idx in range(len(df)):
            cell_val = df.iloc[idx, 2]  # R列
            s = str(cell_val) if cell_val is not None else ""
            found = zh_pattern.findall(s)
            owners.append("".join(found))
        
        assert owners[0] == "王任超"
        assert owners[1] == "李四"
        assert owners[2] == ""
        assert owners[3] == ""
        assert owners[4] == "张三李四"
    
    def test_file2_has_responsible_column_as_none(self):
        """测试文件2的责任人列显示为'无'"""
        # 文件2无责任人列
        responsible_value = "无"
        assert responsible_value == "无"
    
    def test_file3_has_responsible_column(self):
        """测试文件3有责任人列（AP列）"""
        # AP列索引为41
        pass  # 类似文件1的测试逻辑
    
    def test_file4_has_responsible_column(self):
        """测试文件4有责任人列（AH列）"""
        # AH列索引为33
        pass
    
    def test_file5_has_responsible_column(self):
        """测试文件5有责任人列（K列）"""
        # K列索引为10
        pass
    
    def test_file6_has_responsible_column_with_multiple_persons(self):
        """测试文件6有责任人列（X列，多人用逗号分隔）"""
        # X列索引为23
        test_value = "王任超,李四,张三"
        persons = test_value.split(',')
        assert len(persons) == 3
        assert "王任超" in persons


class TestResponsiblePersonDisplay:
    """测试责任人列在GUI中的显示"""
    
    def test_responsible_column_in_display(self):
        """测试责任人列在显示列表中"""
        display_columns = ['状态', '项目号', '接口号', '接口时间', '责任人', '是否已完成']
        assert '责任人' in display_columns
        # 确认位置在"接口时间"之后
        responsible_index = display_columns.index('责任人')
        time_index = display_columns.index('接口时间')
        assert responsible_index == time_index + 1
    
    def test_empty_responsible_shows_none(self):
        """测试空责任人显示为'无'"""
        test_values = [None, '', '  ', float('nan')]
        for val in test_values:
            if pd.isna(val) or str(val).strip() == '':
                result = '无'
            else:
                result = str(val).strip()
            assert result == '无'
    
    def test_responsible_column_width(self):
        """测试责任人列宽度设置"""
        fixed_widths = {
            '状态': 50,
            '项目号': 75,
            '接口号': 240,
            '接口时间': 85,
            '责任人': 100,
            '是否已完成': 95
        }
        assert fixed_widths['责任人'] == 100
```

**运行测试**:
```bash
pytest tests/test_responsible_person_display.py -v
```

#### 步骤1.6: 验证现有测试（10分钟）

**运行全量测试**:
```bash
pytest -v
```

**预期结果**: 247个测试全部通过（可能需要修复少量列顺序相关的测试）

**如果有失败**: 检查是否是列顺序变化导致，修复相关测试用例

#### 步骤1.7: 手动验证（15分钟）

1. 启动程序: `python base.py`
2. 选择测试文件夹
3. 点击"开始筛选"
4. 检查6个选项卡的责任人列：
   - 列是否存在？
   - 列位置是否正确？
   - 数据是否正确显示？
   - 空值是否显示"无"？
   - 列宽是否合适？

#### 阶段1完成标志
- [ ] 所有6个文件类型都有责任人列
- [ ] 责任人列显示在正确位置
- [ ] 空值显示为"无"
- [ ] 列宽设置合理
- [ ] 所有测试通过
- [ ] 手动验证通过

---

## 阶段2: 回文单号输入模块

### 目标
创建 `input_handler.py` 模块，实现点击接口号输入回文单号功能。

### 前置条件
- 阶段1已完成
- 已理解文件3的M列/L列判断逻辑

### 执行步骤

#### 步骤2.1: 创建input_handler.py（1小时）

**文件**: `input_handler.py`

**完整代码结构**:
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
回文单号输入处理模块
"""

import tkinter as tk
from tkinter import ttk, messagebox
import pandas as pd
from openpyxl import load_workbook
from datetime import date
import os


class InterfaceInputDialog(tk.Toplevel):
    """回文单号输入弹窗"""
    
    def __init__(self, parent, interface_id, file_type, file_path, row_index, 
                 user_name, project_id, source_column=None):
        """
        参数:
            parent: 父窗口
            interface_id: 接口号
            file_type: 文件类型(1-6)
            file_path: 原始Excel文件路径
            row_index: Excel行号
            user_name: 当前用户姓名
            project_id: 项目号
            source_column: 文件3专用，'M'或'L'，表示筛选来源
        """
        super().__init__(parent)
        
        self.interface_id = interface_id
        self.file_type = file_type
        self.file_path = file_path
        self.row_index = row_index
        self.user_name = user_name
        self.project_id = project_id
        self.source_column = source_column
        
        self.setup_ui()
    
    def setup_ui(self):
        """设置界面"""
        self.title("回文单号输入")
        self.geometry("400x200")
        self.resizable(False, False)
        
        # 居中显示
        self.transient(self.master)
        self.grab_set()
        
        # 标题
        title_label = ttk.Label(self, text=f"接口号: {self.interface_id}", 
                                font=('Arial', 12, 'bold'))
        title_label.pack(pady=10)
        
        # 输入框
        input_frame = ttk.Frame(self)
        input_frame.pack(pady=10, padx=20, fill='x')
        
        ttk.Label(input_frame, text="回文单号:").pack(side='left', padx=5)
        
        self.entry = ttk.Entry(input_frame, width=30)
        self.entry.pack(side='left', padx=5, fill='x', expand=True)
        self.entry.focus_set()
        
        # 按钮
        button_frame = ttk.Frame(self)
        button_frame.pack(pady=20)
        
        ttk.Button(button_frame, text="确认", command=self.on_confirm).pack(side='left', padx=10)
        ttk.Button(button_frame, text="取消", command=self.destroy).pack(side='left', padx=10)
        
        # 绑定Enter键
        self.entry.bind('<Return>', lambda e: self.on_confirm())
    
    def on_confirm(self):
        """确认按钮回调"""
        response_number = self.entry.get().strip()
        
        if not response_number:
            messagebox.showwarning("警告", "请输入回文单号", parent=self)
            return
        
        # 写入Excel
        try:
            success = write_response_to_excel(
                self.file_path,
                self.file_type,
                self.row_index,
                response_number,
                self.user_name,
                self.project_id,
                self.source_column
            )
            
            if success:
                messagebox.showinfo("成功", "回文单号已保存", parent=self)
                self.destroy()
            else:
                messagebox.showerror("失败", "保存失败，请重试", parent=self)
        except Exception as e:
            messagebox.showerror("错误", f"保存失败: {str(e)}", parent=self)


def write_response_to_excel(file_path, file_type, row_index, response_number, 
                             user_name, project_id, source_column=None):
    """
    写入回文单号到Excel文件
    
    参数:
        file_path: Excel文件路径
        file_type: 文件类型(1-6)
        row_index: Excel行号（从2开始，因为第1行是标题）
        response_number: 回文单号
        user_name: 用户姓名
        project_id: 项目号
        source_column: 文件3专用，'M'或'L'
    
    返回:
        bool: 成功返回True，失败返回False
    """
    try:
        # 检查文件是否存在
        if not os.path.exists(file_path):
            print(f"文件不存在: {file_path}")
            return False
        
        # 文件锁定检测
        try:
            # 尝试以独占模式打开
            with open(file_path, 'r+b') as f:
                pass
        except PermissionError:
            messagebox.showerror("文件占用", "有其他用户占用该文件，请稍后再试")
            return False
        
        # 使用openpyxl打开
        wb = load_workbook(file_path)
        ws = wb.active
        
        # 获取写入列位置
        columns = get_write_columns(file_type, row_index, ws, source_column)
        
        if not columns:
            print(f"无法确定写入列位置: file_type={file_type}")
            return False
        
        # 写入数据
        response_col = columns['response_col']
        time_col = columns['time_col']
        name_col = columns['name_col']
        
        ws[f"{response_col}{row_index}"] = response_number
        ws[f"{time_col}{row_index}"] = date.today().strftime('%Y-%m-%d')
        ws[f"{name_col}{row_index}"] = user_name
        
        # 保存
        wb.save(file_path)
        wb.close()
        
        print(f"成功写入: {file_path}, 行{row_index}, 回文单号={response_number}")
        return True
        
    except Exception as e:
        print(f"写入失败: {e}")
        import traceback
        traceback.print_exc()
        return False


def get_write_columns(file_type, row_index, worksheet, source_column=None):
    """
    获取各文件类型的写入列位置
    
    参数:
        file_type: 文件类型(1-6)
        row_index: Excel行号
        worksheet: openpyxl工作表对象
        source_column: 文件3专用，'M'或'L'
    
    返回:
        dict: {'response_col': 'S', 'time_col': 'N', 'name_col': 'V'}
        或 None（如果无法确定）
    """
    # 文件类型1-2, 4-6的固定列位置
    column_map = {
        1: {'response_col': 'S', 'time_col': 'N', 'name_col': 'V'},
        2: {'response_col': 'P', 'time_col': 'N', 'name_col': 'AL'},
        4: {'response_col': 'U', 'time_col': 'V', 'name_col': 'AT'},
        5: {'response_col': 'V', 'time_col': 'N', 'name_col': 'W'},
        6: {'response_col': 'L', 'time_col': 'J', 'name_col': 'N'},
    }
    
    if file_type in column_map:
        return column_map[file_type]
    
    # 文件3特殊逻辑：根据source_column判断
    if file_type == 3:
        if source_column == 'M':
            # M列筛选：V/T/BM
            return {'response_col': 'V', 'time_col': 'T', 'name_col': 'BM'}
        elif source_column == 'L':
            # L列筛选：S/Q/BM
            return {'response_col': 'S', 'time_col': 'Q', 'name_col': 'BM'}
        else:
            # 如果未指定，尝试自动判断
            return determine_file3_source_and_columns(row_index, worksheet)
    
    return None


def determine_file3_source_and_columns(row_index, worksheet):
    """
    判断文件3某行是因M列还是L列被筛选出
    
    参数:
        row_index: Excel行号
        worksheet: openpyxl工作表对象
    
    返回:
        dict: 写入列位置
    """
    try:
        # 读取M列和L列的值
        m_val = worksheet[f"M{row_index}"].value
        l_val = worksheet[f"L{row_index}"].value
        
        # 读取T列和Q列的值（回复时间列）
        t_val = worksheet[f"T{row_index}"].value
        q_val = worksheet[f"Q{row_index}"].value
        
        # 简化判断逻辑：
        # 如果M列有时间数据且T列为空，判断为M列来源
        # 如果L列有时间数据且Q列为空，判断为L列来源
        # 优先M列
        
        m_has_time = m_val is not None and str(m_val).strip() != ''
        t_is_empty = t_val is None or str(t_val).strip() == ''
        
        l_has_time = l_val is not None and str(l_val).strip() != ''
        q_is_empty = q_val is None or str(q_val).strip() == ''
        
        if m_has_time and t_is_empty:
            # M列来源
            return {'response_col': 'V', 'time_col': 'T', 'name_col': 'BM'}
        elif l_has_time and q_is_empty:
            # L列来源
            return {'response_col': 'S', 'time_col': 'Q', 'name_col': 'BM'}
        else:
            # 默认M列
            return {'response_col': 'V', 'time_col': 'T', 'name_col': 'BM'}
    
    except Exception as e:
        print(f"判断文件3来源失败: {e}")
        # 默认返回M列
        return {'response_col': 'V', 'time_col': 'T', 'name_col': 'BM'}


# 测试代码
if __name__ == "__main__":
    # 测试get_write_columns
    columns_1 = get_write_columns(1, 5, None)
    print(f"文件1写入列: {columns_1}")
    
    columns_3_m = get_write_columns(3, 5, None, 'M')
    print(f"文件3(M列)写入列: {columns_3_m}")
    
    columns_3_l = get_write_columns(3, 5, None, 'L')
    print(f"文件3(L列)写入列: {columns_3_l}")
```

**测试模块**:
```bash
python input_handler.py
```

#### 步骤2.2: 在main.py中添加来源标记（30分钟）

**目的**: 为文件3的每行数据添加 `_source_column` 标记

**文件**: `main.py`

**位置**: `process_target_file3()` 函数

**修改** (约第1448-1452行):

```python
# 转换为最终结果DataFrame
final_indices = [i for i in final_rows if i >= 0]
excel_row_numbers = [i + 2 for i in final_indices]
result_df = df.iloc[final_indices].copy()
result_df['原始行号'] = excel_row_numbers

# 【新增】添加来源标记（用于回文单号输入时判断写入列）
source_columns = []
for idx in final_indices:
    if idx in group1 and idx not in group2:
        source_columns.append('M')  # M列筛选路径
    elif idx in group2 and idx not in group1:
        source_columns.append('L')  # L列筛选路径
    else:
        source_columns.append('M')  # 两者都匹配，优先M列
result_df['_source_column'] = source_columns
```

#### 步骤2.3: 在window.py中绑定点击事件（45分钟）

**文件**: `window.py`

**位置1**: `display_excel_data()` 方法末尾（约第800行）

**添加代码**:
```python
# 【新增】绑定接口号列的单击事件（用于回文单号输入）
def on_interface_click(event):
    # 获取点击的单元格
    region = viewer.identify_region(event.x, event.y)
    if region != "cell":
        return
    
    column_id = viewer.identify_column(event.x)
    row_id = viewer.identify_row(event.y)
    
    if not row_id:
        return
    
    # 检查是否点击的是"接口号"列
    columns = viewer["columns"]
    try:
        col_index = columns.index(column_id.replace('#', ''))
        col_name = columns[col_index]
    except:
        return
    
    if col_name != "接口号":
        return
    
    # 获取当前行数据
    item = viewer.item(row_id)
    values = item['values']
    
    try:
        interface_id = values[columns.index("接口号")]
        row_index_value = values[-1]  # 最后一列是原始行号
        
        # 获取文件类型和文件路径
        # 需要从外部传入或通过其他方式获取
        # 这里假设有self.app的引用
        
        # 弹出输入框
        from input_handler import InterfaceInputDialog
        
        # 获取必要参数
        user_name = getattr(self.app, 'user_name', '')
        file_type = self._get_file_type_from_tab(tab_name)
        file_path = self._get_source_file_path(row_index_value, source_files)
        project_id = values[columns.index("项目号")] if "项目号" in columns else ""
        
        # 文件3需要获取source_column
        source_column = None
        if file_type == 3:
            # 从原始数据中获取
            source_column = self._get_source_column(row_index_value, tab_name)
        
        # 显示输入对话框
        dialog = InterfaceInputDialog(
            self.root,
            interface_id,
            file_type,
            file_path,
            row_index_value,
            user_name,
            project_id,
            source_column
        )
        dialog.wait_window()
        
    except Exception as e:
        print(f"点击接口号处理失败: {e}")
        import traceback
        traceback.print_exc()

viewer.bind("<Button-1>", on_interface_click)
```

**位置2**: 添加辅助方法

```python
def _get_file_type_from_tab(self, tab_name):
    """根据选项卡名称获取文件类型"""
    tab_map = {
        "内部需打开接口": 1,
        "内部需回复接口": 2,
        "外部需打开接口": 3,
        "外部需回复接口": 4,
        "三维提资接口": 5,
        "收发文函": 6
    }
    return tab_map.get(tab_name, 1)

def _get_source_file_path(self, row_index, source_files):
    """获取源文件路径"""
    # source_files是传入的文件路径映射
    if source_files and row_index in source_files:
        return source_files[row_index]
    return None

def _get_source_column(self, row_index, tab_name):
    """获取文件3的source_column标记"""
    # 需要从原始DataFrame中获取
    # 这里需要在display_excel_data时保存一份原始数据的引用
    try:
        if hasattr(self, '_original_data') and tab_name in self._original_data:
            df = self._original_data[tab_name]
            row_data = df[df['原始行号'] == row_index]
            if not row_data.empty and '_source_column' in row_data.columns:
                return row_data.iloc[0]['_source_column']
    except:
        pass
    return 'M'  # 默认M列
```

**位置3**: 修改 `display_excel_data()` 保存原始数据

```python
def display_excel_data(self, viewer, df, tab_name, ...):
    # ... 前面的代码 ...
    
    # 【新增】保存原始数据引用（用于获取source_column）
    if not hasattr(self, '_original_data'):
        self._original_data = {}
    self._original_data[tab_name] = df.copy()
    
    # ... 后续代码 ...
```

#### 步骤2.4: 在base.py中集成模块（15分钟）

**文件**: `base.py`

**位置**: 文件顶部导入区

**添加导入**:
```python
# 导入回文单号输入模块
try:
    import input_handler
except ImportError:
    print("警告: 未找到input_handler模块")
    input_handler = None
```

**位置**: `display_excel_data_with_original_rows()` 方法

**传递source_files参数**:
```python
def display_excel_data_with_original_rows(self, viewer, df, label_text, excel_row_numbers):
    """显示数据到Treeview"""
    # 构建source_files映射（原始行号 → 文件路径）
    source_files = {}
    if 'source_file' in df.columns:
        for idx, row in df.iterrows():
            row_num = row.get('原始行号', 0)
            source_file = row.get('source_file', '')
            if row_num and source_file:
                source_files[row_num] = source_file
    
    # 传递给window_manager
    self.window_manager.display_excel_data(
        viewer, 
        df, 
        label_text, 
        excel_row_numbers=excel_row_numbers,
        source_files=source_files  # 新增参数
    )
```

#### 步骤2.5: 添加source_file列（30分钟）

**文件**: `main.py`

**在每个 `process_target_fileX()` 函数中添加**:

```python
# 在返回result_df之前添加
result_df['source_file'] = file_path
```

**示例**（文件1，约第467行）:
```python
    result_df['责任人'] = owners
    result_df['source_file'] = file_path  # 新增
    return result_df
```

**同样修改**: 文件2/3/4/5/6的process函数

#### 步骤2.6: 编写测试用例（1小时）

**文件**: `tests/test_input_handler.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
回文单号输入功能测试
"""

import pytest
import os
import pandas as pd
from openpyxl import load_workbook
from datetime import date
from input_handler import (
    get_write_columns,
    write_response_to_excel,
    determine_file3_source_and_columns
)


class TestGetWriteColumns:
    """测试获取写入列位置"""
    
    def test_file1_columns(self):
        """测试文件1的写入列"""
        columns = get_write_columns(1, 5, None)
        assert columns == {'response_col': 'S', 'time_col': 'N', 'name_col': 'V'}
    
    def test_file2_columns(self):
        """测试文件2的写入列"""
        columns = get_write_columns(2, 5, None)
        assert columns == {'response_col': 'P', 'time_col': 'N', 'name_col': 'AL'}
    
    def test_file3_m_column(self):
        """测试文件3-M列的写入列"""
        columns = get_write_columns(3, 5, None, 'M')
        assert columns == {'response_col': 'V', 'time_col': 'T', 'name_col': 'BM'}
    
    def test_file3_l_column(self):
        """测试文件3-L列的写入列"""
        columns = get_write_columns(3, 5, None, 'L')
        assert columns == {'response_col': 'S', 'time_col': 'Q', 'name_col': 'BM'}
    
    def test_file4_columns(self):
        """测试文件4的写入列"""
        columns = get_write_columns(4, 5, None)
        assert columns == {'response_col': 'U', 'time_col': 'V', 'name_col': 'AT'}
    
    def test_file5_columns(self):
        """测试文件5的写入列"""
        columns = get_write_columns(5, 5, None)
        assert columns == {'response_col': 'V', 'time_col': 'N', 'name_col': 'W'}
    
    def test_file6_columns(self):
        """测试文件6的写入列"""
        columns = get_write_columns(6, 5, None)
        assert columns == {'response_col': 'L', 'time_col': 'J', 'name_col': 'N'}


class TestWriteResponseToExcel:
    """测试写入Excel功能"""
    
    @pytest.fixture
    def temp_excel_file(self, tmp_path):
        """创建临时Excel文件"""
        file_path = tmp_path / "test_file1.xlsx"
        
        # 创建测试数据
        df = pd.DataFrame({
            'A': ['数据1', '数据2', '数据3'],
            'N': ['', '', ''],  # 时间列
            'S': ['', '', ''],  # 回文单号列
            'V': ['', '', '']   # 用户姓名列
        })
        
        df.to_excel(file_path, index=False, engine='openpyxl')
        return str(file_path)
    
    def test_write_to_file1(self, temp_excel_file):
        """测试写入文件1"""
        success = write_response_to_excel(
            temp_excel_file,
            1,  # 文件类型1
            2,  # 第2行（Excel中第2行，DataFrame第1行）
            "HW-001",  # 回文单号
            "测试用户",
            "2016"
        )
        
        assert success
        
        # 验证写入内容
        wb = load_workbook(temp_excel_file)
        ws = wb.active
        
        assert ws['S2'].value == "HW-001"
        assert ws['N2'].value == date.today().strftime('%Y-%m-%d')
        assert ws['V2'].value == "测试用户"
        
        wb.close()
    
    def test_write_to_nonexistent_file(self):
        """测试写入不存在的文件"""
        success = write_response_to_excel(
            "/path/to/nonexistent/file.xlsx",
            1,
            2,
            "HW-001",
            "测试用户",
            "2016"
        )
        
        assert not success


class TestFile3SourceDetermination:
    """测试文件3来源判断"""
    
    @pytest.fixture
    def temp_file3(self, tmp_path):
        """创建临时文件3"""
        file_path = tmp_path / "test_file3.xlsx"
        
        # 创建测试数据
        df = pd.DataFrame({
            'L': ['2025-10-28', '', '2025-11-01'],  # L列时间
            'M': ['', '2025-10-30', '2025-11-02'],  # M列时间
            'Q': ['', '2025-10-25', ''],  # Q列回复时间
            'T': ['2025-10-26', '', '']   # T列回复时间
        })
        
        df.to_excel(file_path, index=False, engine='openpyxl')
        return str(file_path)
    
    def test_determine_m_source(self, temp_file3):
        """测试判断为M列来源"""
        wb = load_workbook(temp_file3)
        ws = wb.active
        
        columns = determine_file3_source_and_columns(3, ws)
        assert columns['response_col'] == 'V'  # M列来源
        
        wb.close()
    
    def test_determine_l_source(self, temp_file3):
        """测试判断为L列来源"""
        wb = load_workbook(temp_file3)
        ws = wb.active
        
        columns = determine_file3_source_and_columns(2, ws)
        assert columns['response_col'] == 'S'  # L列来源
        
        wb.close()
```

**运行测试**:
```bash
pytest tests/test_input_handler.py -v
```

#### 步骤2.7: 手动验证（30分钟）

1. 启动程序
2. 进行一次筛选
3. 点击任意接口号
4. 检查弹窗是否正常显示
5. 输入回文单号并确认
6. 打开对应Excel文件，验证数据是否正确写入
7. 测试6种文件类型（特别是文件3的M/L列判断）
8. 测试并发场景（打开Excel文件后，再次点击接口号）

#### 阶段2完成标志
- [ ] `input_handler.py` 模块创建完成
- [ ] 文件3添加了 `_source_column` 标记
- [ ] window.py绑定了点击事件
- [ ] 所有文件添加了 `source_file` 列
- [ ] 测试用例全部通过
- [ ] 手动验证6种文件类型都能正确写入
- [ ] 并发写入保护生效

---

## 阶段3: 任务指派模块

### 目标
创建 `distribution.py` 模块，实现接口工程师和室主任的任务指派功能。

### 前置条件
- 阶段1和阶段2已完成
- 已理解角色权限过滤逻辑

### 执行步骤

#### 步骤3.1: 创建distribution.py（2小时）

**文件**: `distribution.py`

**完整代码结构**: (代码太长，见完整文件)

核心类和函数：
- `AssignmentDialog`: 指派界面
- `check_unassigned()`: 检测未指派任务
- `get_name_list()`: 获取姓名列表
- `save_assignment()`: 保存指派结果

#### 步骤3.2: 在file_manager.py添加记忆功能（30分钟）

**文件**: `file_manager.py`

**位置**: `FileIdentityManager` 类

**添加属性**:
```python
def __init__(self, cache_file="file_cache.json", result_cache_dir="result_cache"):
    # ... 现有代码 ...
    
    # 【新增】接口记忆功能（文件2专用）
    self.interface_memory = {}  # {project_id_interface_id: assigned_name}
```

**添加方法**:
```python
def save_interface_memory(self, cache_key, assigned_name):
    """保存接口指派记忆"""
    self.interface_memory[cache_key] = assigned_name
    self._save_cache()

def get_interface_memory(self, cache_key):
    """获取接口指派记忆"""
    return self.interface_memory.get(cache_key, "")

def clear_interface_memory(self):
    """清空接口记忆"""
    self.interface_memory = {}
    self._save_cache()
```

**修改缓存加载和保存**:
```python
def _load_cache(self):
    # ... 现有代码 ...
    
    # 加载接口记忆
    if 'interface_memory' in data:
        self.interface_memory = data['interface_memory']

def _save_cache(self):
    data = {
        'file_identities': self.file_identities,
        'completed_rows': self.completed_rows,
        'interface_memory': self.interface_memory  # 新增
    }
    # ... 保存代码 ...
```

#### 步骤3.3: 在base.py集成指派功能（2小时）

**步骤3.3.1**: 添加检测逻辑

**文件**: `base.py`

**位置**: `start_processing()` 方法末尾

**添加代码**:
```python
# 【新增】检测是否需要指派任务（仅接口工程师和室主任）
if self._should_show_assignment_reminder():
    self._show_assignment_reminder()
```

**添加方法**:
```python
def _should_show_assignment_reminder(self):
    """判断是否需要显示指派提醒"""
    # 检查角色
    user_roles = getattr(self, 'user_roles', [])
    
    # 只有接口工程师和室主任需要指派
    has_assignment_role = any(
        role in ['一室主任', '二室主任', '建筑总图室主任'] or 
        '接口工程师' in role
        for role in user_roles
    )
    
    if not has_assignment_role:
        return False
    
    # 检查是否有未指派任务
    unassigned = self._check_unassigned_tasks()
    return len(unassigned) > 0

def _check_unassigned_tasks(self):
    """检测未指派任务"""
    from distribution import check_unassigned
    
    # 收集所有处理结果
    processed_results = {}
    for i in range(1, 7):
        result_attr = f'processing_results{i}'
        if hasattr(self, result_attr):
            df = getattr(self, result_attr)
            if df is not None and not df.empty:
                processed_results[i] = df
    
    # 检测未指派任务
    user_roles = getattr(self, 'user_roles', [])
    project_id = self._get_my_project_id()
    
    unassigned = check_unassigned(processed_results, user_roles, project_id)
    return unassigned

def _get_my_project_id(self):
    """获取接口工程师负责的项目号"""
    user_roles = getattr(self, 'user_roles', [])
    
    for role in user_roles:
        if '接口工程师' in role:
            # 提取项目号（如"2016接口工程师" → "2016"）
            project_id = self._parse_interface_engineer_role(role)
            if project_id:
                return project_id
    
    return None

def _show_assignment_reminder(self):
    """显示指派提醒弹窗"""
    from tkinter import messagebox
    from distribution import AssignmentDialog, get_name_list
    
    unassigned = self._check_unassigned_tasks()
    count = len(unassigned)
    
    # 提醒弹窗
    result = messagebox.askyesno(
        "任务指派提醒",
        f"您有 {count} 个需要指派的接口任务\n请注意\n\n是否现在指派？",
        parent=self.root
    )
    
    if result:
        # 现在指派
        name_list = get_name_list()
        dialog = AssignmentDialog(
            self.root,
            unassigned,
            self.file_manager,
            name_list
        )
        dialog.wait_window()
    else:
        # 取消 - 显示"指派任务"按钮
        self._show_assignment_button()

def _show_assignment_button(self):
    """显示"指派任务"按钮"""
    if hasattr(self, '_assignment_button') and self._assignment_button:
        # 按钮已存在
        return
    
    # 创建按钮
    import tkinter as tk
    from tkinter import ttk
    
    button_frame = ttk.Frame(self.root)
    button_frame.pack(side='bottom', fill='x', pady=5)
    
    self._assignment_button = ttk.Button(
        button_frame,
        text="指派任务",
        command=self._on_assignment_button_click
    )
    self._assignment_button.pack(side='right', padx=10)

def _on_assignment_button_click(self):
    """指派任务按钮点击"""
    from distribution import AssignmentDialog, get_name_list
    
    unassigned = self._check_unassigned_tasks()
    if not unassigned:
        messagebox.showinfo("提示", "当前没有需要指派的任务", parent=self.root)
        return
    
    name_list = get_name_list()
    dialog = AssignmentDialog(
        self.root,
        unassigned,
        self.file_manager,
        name_list
    )
    dialog.wait_window()
```

**步骤3.3.2**: 自动模式集成

**位置**: `update_display()` 方法

```python
def update_display(self):
    """自动模式下更新显示"""
    # ... 现有代码 ...
    
    # 导出结果
    if self.export_after_processing_var.get():
        self.export_results()
    
    # 【新增】检测指派任务（在导出后）
    if self._should_show_assignment_reminder():
        self.root.after(1000, self._show_assignment_reminder)  # 延迟1秒
```

#### 步骤3.4: 编写测试用例（1.5小时）

**文件**: `tests/test_distribution.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
任务指派功能测试
"""

import pytest
import pandas as pd
from distribution import (
    check_unassigned,
    get_name_list,
    get_responsible_column
)


class TestCheckUnassigned:
    """测试检测未指派任务"""
    
    def test_detect_empty_responsible(self):
        """测试检测责任人为空的数据"""
        df = pd.DataFrame({
            '项目号': ['2016', '2016', '2026'],
            '接口号': ['INT-001', 'INT-002', 'INT-003'],
            '责任人': ['王任超', '', None],
            '科室': ['结构一室', '结构一室', '结构二室'],
            '原始行号': [2, 3, 4],
            'source_file': ['file1.xlsx'] * 3
        })
        
        processed_results = {1: df}
        user_roles = ['一室主任']
        
        unassigned = check_unassigned(processed_results, user_roles)
        
        assert len(unassigned) == 1
        assert unassigned[0]['interface_id'] == 'INT-002'
    
    def test_interface_engineer_filter(self):
        """测试接口工程师只看自己项目"""
        df = pd.DataFrame({
            '项目号': ['2016', '2016', '2026'],
            '接口号': ['INT-001', 'INT-002', 'INT-003'],
            '责任人': ['', '', ''],
            '科室': ['结构一室'] * 3,
            '原始行号': [2, 3, 4],
            'source_file': ['file1.xlsx'] * 3
        })
        
        processed_results = {1: df}
        user_roles = ['2016接口工程师']
        project_id = '2016'
        
        unassigned = check_unassigned(processed_results, user_roles, project_id)
        
        assert len(unassigned) == 2
        assert all(task['project_id'] == '2016' for task in unassigned)
    
    def test_director_filter(self):
        """测试室主任只看自己科室"""
        df = pd.DataFrame({
            '项目号': ['2016'] * 4,
            '接口号': ['INT-001', 'INT-002', 'INT-003', 'INT-004'],
            '责任人': ['', '', '', ''],
            '科室': ['结构一室', '结构二室', '请室主任确认', '建筑总图室'],
            '原始行号': [2, 3, 4, 5],
            'source_file': ['file1.xlsx'] * 4
        })
        
        processed_results = {1: df}
        user_roles = ['一室主任']
        
        unassigned = check_unassigned(processed_results, user_roles)
        
        assert len(unassigned) == 2
        interfaces = [task['interface_id'] for task in unassigned]
        assert 'INT-001' in interfaces  # 结构一室
        assert 'INT-003' in interfaces  # 请室主任确认


class TestGetNameList:
    """测试获取姓名列表"""
    
    def test_get_name_list(self):
        """测试从姓名角色表读取姓名"""
        names = get_name_list()
        assert isinstance(names, list)
        assert len(names) > 0
        # 假设表中有"王任超"
        # assert "王任超" in names


class TestResponsibleColumn:
    """测试责任人列位置"""
    
    def test_file1_responsible_column(self):
        """测试文件1责任人列"""
        col = get_responsible_column(1)
        assert col == 'R'
    
    def test_file2_no_responsible_column(self):
        """测试文件2无责任人列"""
        col = get_responsible_column(2)
        assert col is None
    
    def test_file3_responsible_column(self):
        """测试文件3责任人列"""
        col = get_responsible_column(3)
        assert col == 'AP'
```

**运行测试**:
```bash
pytest tests/test_distribution.py -v
```

#### 步骤3.5: 手动验证（1小时）

1. **准备测试数据**: 创建包含无责任人数据的Excel文件
2. **测试接口工程师**:
   - 登录为接口工程师角色
   - 进行筛选
   - 检查是否弹出指派提醒
   - 点击"现在指派"
   - 检查列表是否只显示自己项目的数据
   - 选择姓名并指派
   - 验证Excel文件是否正确写入
3. **测试室主任**:
   - 登录为室主任角色
   - 进行筛选
   - 检查是否弹出指派提醒
   - 检查列表是否只显示自己科室的数据
   - 指派任务
4. **测试文件2记忆功能**:
   - 指派文件2的某个接口给"王任超"
   - 再次打开指派界面
   - 检查该接口是否自动填充"王任超"
5. **测试"取消"按钮**:
   - 点击取消关闭指派弹窗
   - 检查"指派任务"按钮是否显示
   - 点击"指派任务"按钮
   - 检查指派界面是否重新打开
6. **测试实时搜索**:
   - 在指派界面的下拉框中输入"王"
   - 检查是否只显示"王"开头的姓名
7. **测试自动模式**:
   - 启用自动模式
   - 等待自动筛选完成
   - 检查导出后是否弹出指派提醒

#### 阶段3完成标志
- [ ] `distribution.py` 模块创建完成
- [ ] file_manager.py添加了记忆功能
- [ ] base.py集成了指派检测和提醒
- [ ] "指派任务"按钮功能正常
- [ ] 实时搜索功能正常
- [ ] 文件2记忆功能正常
- [ ] 测试用例全部通过
- [ ] 手动验证通过

---

## 阶段4: 指派追踪功能

### 目标
实现接口工程师和室主任查看已指派任务的完成状态。

### 前置条件
- 阶段3已完成

### 执行步骤

#### 步骤4.1: 在base.py添加追踪入口（30分钟）

**文件**: `base.py`

**位置**: 菜单栏或工具栏

**添加菜单项**:
```python
# 在setup_menu()方法中添加
def setup_menu(self):
    # ... 现有代码 ...
    
    # 【新增】任务追踪菜单
    track_menu = tk.Menu(menubar, tearoff=0)
    menubar.add_cascade(label="任务追踪", menu=track_menu)
    
    track_menu.add_command(label="查看已指派任务", command=self.show_assigned_tasks)
    track_menu.add_separator()
    track_menu.add_command(label="刷新追踪", command=self.refresh_tracking)
```

**添加方法**:
```python
def show_assigned_tasks(self):
    """显示已指派任务追踪"""
    from distribution import show_tracking_dialog
    
    # 收集所有处理结果
    processed_results = {}
    for i in range(1, 7):
        result_attr = f'processing_results{i}'
        if hasattr(self, result_attr):
            df = getattr(self, result_attr)
            if df is not None and not df.empty:
                processed_results[i] = df
    
    user_roles = getattr(self, 'user_roles', [])
    project_id = self._get_my_project_id()
    
    show_tracking_dialog(self.root, processed_results, user_roles, project_id)

def refresh_tracking(self):
    """刷新追踪数据"""
    # 重新处理数据
    self.start_processing()
    # 显示追踪界面
    self.show_assigned_tasks()
```

#### 步骤4.2: 在distribution.py添加追踪功能（1.5小时）

**文件**: `distribution.py`

**添加类**:
```python
class TrackingDialog(tk.Toplevel):
    """任务追踪界面"""
    
    def __init__(self, parent, assigned_tasks):
        """
        参数:
            parent: 父窗口
            assigned_tasks: 已指派任务列表
        """
        super().__init__(parent)
        
        self.assigned_tasks = assigned_tasks
        self.setup_ui()
    
    def setup_ui(self):
        """设置界面"""
        self.title("任务追踪")
        self.geometry("900x600")
        
        # 标题
        title_label = ttk.Label(
            self,
            text=f"已指派任务追踪（共{len(self.assigned_tasks)}个）",
            font=('Arial', 14, 'bold')
        )
        title_label.pack(pady=10)
        
        # 创建Treeview
        columns = ('项目号', '接口号', '责任人', '指派状态', '接口时间')
        
        tree_frame = ttk.Frame(self)
        tree_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # 滚动条
        scrollbar = ttk.Scrollbar(tree_frame)
        scrollbar.pack(side='right', fill='y')
        
        self.tree = ttk.Treeview(
            tree_frame,
            columns=columns,
            show='headings',
            yscrollcommand=scrollbar.set
        )
        scrollbar.config(command=self.tree.yview)
        
        # 设置列标题
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=150, anchor='center')
        
        self.tree.pack(fill='both', expand=True)
        
        # 填充数据
        self.populate_data()
        
        # 关闭按钮
        ttk.Button(self, text="关闭", command=self.destroy).pack(pady=10)
    
    def populate_data(self):
        """填充数据"""
        for task in self.assigned_tasks:
            values = (
                task.get('project_id', ''),
                task.get('interface_id', ''),
                task.get('responsible', ''),
                task.get('status', ''),
                task.get('interface_time', '')
            )
            self.tree.insert('', 'end', values=values)


def get_assigned_tasks_with_status(processed_results, user_roles, project_id=None):
    """
    获取已指派任务及其完成状态
    
    返回:
        list: 任务列表，每个任务包含status字段（"已完成"或"待完成"）
    """
    assigned_tasks = []
    
    for file_type, df in processed_results.items():
        if df is None or df.empty:
            continue
        
        # 筛选有责任人的数据
        has_responsible = (df['责任人'].notna()) & (df['责任人'].astype(str).str.strip() != '') & (df['责任人'].astype(str).str.strip() != '无')
        df_assigned = df[has_responsible].copy()
        
        if df_assigned.empty:
            continue
        
        # 角色权限过滤
        if is_interface_engineer(user_roles):
            df_assigned = df_assigned[df_assigned['项目号'] == project_id]
        elif is_director(user_roles):
            my_department = get_department(user_roles)
            df_assigned = df_assigned[df_assigned['科室'].isin([my_department, '请室主任确认'])]
        
        # 判断完成状态（基于回复时间列）
        reply_time_col = get_reply_time_column(file_type)
        
        for idx, row in df_assigned.iterrows():
            # 检查回复时间列
            reply_time = row.get(reply_time_col, '')
            
            if pd.notna(reply_time) and str(reply_time).strip() != '':
                status = "✅ 已完成"
            else:
                status = "⏳ 待完成"
            
            assigned_tasks.append({
                'file_type': file_type,
                'project_id': row.get('项目号', ''),
                'interface_id': row.get('接口号', ''),
                'responsible': row.get('责任人', ''),
                'status': status,
                'interface_time': row.get('接口时间', ''),
                'file_path': row.get('source_file', ''),
                'row_index': row.get('原始行号', 0)
            })
    
    return assigned_tasks


def get_reply_time_column(file_type):
    """获取回复时间列名（用于判断是否完成）"""
    # 回复时间列不在DataFrame中，需要从原始Excel读取
    # 这里返回应该检查的列索引
    reply_time_map = {
        1: 13,  # N列
        2: 13,  # N列
        3: (16, 19),  # Q列或T列
        4: 21,  # V列
        5: 13,  # N列
        6: 9    # J列
    }
    return reply_time_map.get(file_type, 13)


def show_tracking_dialog(parent, processed_results, user_roles, project_id=None):
    """显示追踪对话框"""
    assigned_tasks = get_assigned_tasks_with_status(processed_results, user_roles, project_id)
    
    if not assigned_tasks:
        messagebox.showinfo("提示", "当前没有已指派的任务", parent=parent)
        return
    
    dialog = TrackingDialog(parent, assigned_tasks)
    dialog.wait_window()
```

#### 步骤4.3: 编写测试用例（45分钟）

**文件**: `tests/test_tracking.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
任务追踪功能测试
"""

import pytest
import pandas as pd
from distribution import (
    get_assigned_tasks_with_status,
    get_reply_time_column
)


class TestTracking:
    """测试任务追踪功能"""
    
    def test_detect_completed_tasks(self):
        """测试检测已完成任务"""
        df = pd.DataFrame({
            '项目号': ['2016', '2016'],
            '接口号': ['INT-001', 'INT-002'],
            '责任人': ['王任超', '李四'],
            '接口时间': ['10.28', '10.29'],
            '科室': ['结构一室', '结构一室'],
            '原始行号': [2, 3],
            'source_file': ['file1.xlsx'] * 2,
            # 回复时间列（需要从原始Excel读取，这里模拟）
            '_reply_time': ['2025-10-29', '']  # 第一个已完成，第二个待完成
        })
        
        processed_results = {1: df}
        user_roles = ['一室主任']
        
        # 这里需要修改get_assigned_tasks_with_status来支持_reply_time列
        # 实际实现时需要从原始Excel读取
        
        # 简化测试
        has_reply = df['_reply_time'].notna() & (df['_reply_time'].astype(str).str.strip() != '')
        assert has_reply.iloc[0] == True
        assert has_reply.iloc[1] == False
    
    def test_get_reply_time_column(self):
        """测试获取回复时间列"""
        assert get_reply_time_column(1) == 13  # N列
        assert get_reply_time_column(2) == 13
        assert get_reply_time_column(3) == (16, 19)  # Q或T列
        assert get_reply_time_column(4) == 21
        assert get_reply_time_column(5) == 13
        assert get_reply_time_column(6) == 9
```

#### 步骤4.4: 手动验证（30分钟）

1. 先完成阶段3的指派操作
2. 使用input_handler输入回文单号（标记为已完成）
3. 打开"任务追踪"菜单
4. 检查已完成和待完成的任务显示是否正确
5. 验证筛选逻辑是否正确（接口工程师/室主任）

#### 阶段4完成标志
- [ ] 追踪功能菜单添加完成
- [ ] TrackingDialog界面创建完成
- [ ] 完成状态判断逻辑正确
- [ ] 测试用例通过
- [ ] 手动验证通过

---

## 阶段5: 缓存适配与集成

### 目标
确保新功能与现有缓存机制兼容，适配自动运行模式。

### 前置条件
- 阶段1-4已完成

### 执行步骤

#### 步骤5.1: 验证缓存失效机制（30分钟）

**测试场景**:
1. 输入回文单号后，Excel文件修改时间改变
2. 再次筛选时，缓存应该失效
3. 重新读取Excel，新数据应该生效

**验证代码**:
```python
# 1. 第一次筛选
result1 = process_target_file1(file_path, datetime.now())

# 2. 输入回文单号（修改Excel）
write_response_to_excel(file_path, 1, 2, "HW-001", "测试用户", "2016")

# 3. 第二次筛选
result2 = process_target_file1(file_path, datetime.now())

# 验证：文件哈希应该不同
identity1 = file_manager.generate_file_identity(file_path)
identity2 = file_manager.generate_file_identity(file_path)
assert identity1 != identity2
```

#### 步骤5.2: 验证自动模式集成（30分钟）

**测试步骤**:
1. 启用自动模式
2. 设置2分钟刷新间隔
3. 等待第一次自动筛选完成
4. 检查是否弹出指派提醒（如果有未指派任务）
5. 指派任务后，等待下次自动刷新
6. 检查指派的任务是否生效

#### 步骤5.3: 验证并发场景（30分钟）

**场景1**: 多个用户同时输入回文单号
- 第一个用户：正常写入
- 第二个用户：收到"文件占用"提示

**场景2**: 用户输入回文单号时，自动刷新触发
- 应该等待输入完成后再刷新

#### 步骤5.4: 验证勾选状态隔离（15分钟）

**测试步骤**:
1. 用户A登录，勾选某些行
2. 切换到用户B
3. 用户B的界面应该看不到用户A的勾选
4. 用户B指派任务后，不应该影响用户A

#### 步骤5.5: 运行全量测试（15分钟）

```bash
pytest -v
```

**预期结果**: 所有测试通过（新增约30个测试用例）

#### 阶段5完成标志
- [ ] 缓存失效机制正常
- [ ] 自动模式集成成功
- [ ] 并发场景处理正确
- [ ] 勾选状态隔离正常
- [ ] 全量测试通过

---

## 阶段6: 打包与验收

### 目标
更新打包配置，生成EXE，全面验收功能。

### 前置条件
- 阶段1-5已完成

### 执行步骤

#### 步骤6.1: 更新打包配置（15分钟）

**文件**: `excel_processor.spec`

**修改**:
```python
a = Analysis(
    ['base.py'],
    pathex=[],
    binaries=[],
    datas=[
        ('ico_bin', 'ico_bin'),
        ('excel_bin', 'excel_bin'),
        ('config.json', '.'),
    ],
    hiddenimports=[
        'pandas',
        'numpy',
        'openpyxl',
        'pystray',
        'PIL',
        'input_handler',      # 新增
        'distribution',       # 新增
    ],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
)
```

#### 步骤6.2: 执行打包（10分钟）

```bash
pyinstaller -y excel_processor.spec
```

**检查输出**:
- `dist/接口筛选/接口筛选.exe` 是否生成
- 文件大小是否合理（约150MB）

#### 步骤6.3: EXE功能验收（1小时）

**验收清单**:

**基础功能**:
- [ ] 程序启动正常
- [ ] 加载配置正常
- [ ] 扫描文件夹正常
- [ ] 开始筛选功能正常
- [ ] 导出结果功能正常

**新功能 - 责任人列**:
- [ ] 6个选项卡都显示责任人列
- [ ] 列位置正确
- [ ] 数据正确
- [ ] 空值显示"无"

**新功能 - 回文单号输入**:
- [ ] 点击接口号弹出输入框
- [ ] 输入回文单号并保存
- [ ] Excel文件正确写入（6种文件类型）
- [ ] 文件3的M/L列判断正确
- [ ] 并发保护生效

**新功能 - 任务指派**:
- [ ] 接口工程师看到指派提醒
- [ ] 室主任看到指派提醒
- [ ] 指派界面显示正确
- [ ] 下拉列表数据正确
- [ ] 实时搜索功能正常
- [ ] 文件2记忆功能正常
- [ ] 指派保存成功
- [ ] "指派任务"按钮功能正常

**新功能 - 任务追踪**:
- [ ] 追踪菜单正常
- [ ] 追踪界面显示正确
- [ ] 完成状态判断正确

**兼容性**:
- [ ] 所有原有功能正常
- [ ] 角色权限正常
- [ ] 缓存机制正常
- [ ] 自动模式正常

#### 步骤6.4: 性能测试（15分钟）

**测试指标**:
- 启动时间: < 2秒
- 筛选10个文件: < 10秒
- 打开指派界面: < 1秒
- 输入回文单号: < 2秒（含Excel写入）

#### 步骤6.5: 生成验收报告（20分钟）

**文件**: `document/功能验收报告.md`

**内容**:
- 功能完成情况
- 测试结果汇总
- 已知问题（如果有）
- 后续优化建议

#### 阶段6完成标志
- [ ] 打包配置更新完成
- [ ] EXE成功生成
- [ ] 所有功能验收通过
- [ ] 性能测试通过
- [ ] 验收报告生成

---

## 总结与交付

### 交付物清单

**代码文件**:
- [ ] `input_handler.py` - 回文单号输入模块
- [ ] `distribution.py` - 任务指派模块
- [ ] 修改的 `base.py`
- [ ] 修改的 `window.py`
- [ ] 修改的 `main.py`
- [ ] 修改的 `file_manager.py`
- [ ] 更新的 `excel_processor.spec`

**测试文件**:
- [ ] `tests/test_responsible_person_display.py`
- [ ] `tests/test_input_handler.py`
- [ ] `tests/test_distribution.py`
- [ ] `tests/test_tracking.py`

**文档文件**:
- [ ] `document/回文单号与任务指派功能需求文档.md`
- [ ] `document/回文单号与任务指派功能执行计划.md`（本文档）
- [ ] `document/功能验收报告.md`

**可执行文件**:
- [ ] `dist/接口筛选/接口筛选.exe`

### 验收标准

1. **功能完整性**: 所有需求功能全部实现 ✅
2. **向后兼容性**: 现有功能零破坏 ✅
3. **测试覆盖率**: 新增30+测试用例，全部通过 ✅
4. **代码质量**: 遵循现有代码风格，充分注释 ✅
5. **性能要求**: 满足性能指标 ✅
6. **用户体验**: 界面友好，操作流畅 ✅

### 后续优化建议

1. **性能优化**: 
   - 大文件处理时的进度条显示
   - 指派界面的虚拟滚动（如果任务数量很大）

2. **功能增强**:
   - 批量指派功能
   - 指派历史记录
   - 导出指派报表

3. **用户体验**:
   - 键盘快捷键支持
   - 右键菜单
   - 双击接口号也触发输入

---

**执行计划完成！祝实施顺利！🚀**

