# 回文单号与任务指派功能 - 详细需求文档

> **版本**: 1.0  
> **创建日期**: 2025-10-30  
> **目标**: 为接口筛选程序添加回文单号输入和任务指派功能

---

## 📋 目录

1. [功能概述](#功能概述)
2. [详细需求说明](#详细需求说明)
3. [技术实现方案](#技术实现方案)
4. [数据流转设计](#数据流转设计)
5. [关键逻辑说明](#关键逻辑说明)
6. [测试要求](#测试要求)

---

## 功能概述

### 核心功能

**功能1: 回文单号输入模块** (`input_handler.py`)
- 所有角色都可在GUI界面点击接口号
- 弹出输入框，填写回文单号
- 自动写入Excel文件（回文单号、时间、姓名）
- 支持并发控制，防止多用户冲突

**功能2: 任务指派模块** (`distribution.py`)
- 接口工程师和室主任专属功能
- 自动检测无责任人的数据
- 弹窗提醒并支持指派
- 智能下拉选择（姓名角色表）
- 支持实时搜索过滤

**功能3: 责任人列显示**
- 主显示窗新增"责任人"列
- 各文件从不同列读取责任人
- 空值显示"无"

**功能4: 指派追踪功能**
- 接口工程师/室主任查看指派任务的完成状态
- 区分"已指派未完成"和"已指派已完成"

---

## 详细需求说明

### 需求1: 回文单号输入功能

#### 1.1 触发条件
- **所有选项卡**（6个）都支持
- 用户点击Treeview中的"接口号"单元格
- **所有角色**都可使用（填写后视为设计人员）

#### 1.2 输入界面
```
┌──────────────────────────────────┐
│      回文单号输入                 │
├──────────────────────────────────┤
│ 回文单号：                        │
│ ┌──────────────────────────────┐ │
│ │ [输入框]                     │ │
│ └──────────────────────────────┘ │
│                                  │
│   [确认]  [取消]                 │
└──────────────────────────────────┘
```

#### 1.3 数据写入位置

| 文件类型 | 回文单号列 | 时间列 | 用户姓名列 | 特殊说明 |
|---------|-----------|--------|-----------|---------|
| **文件1** | S列(18) | N列(13) | V列(21) | 无 |
| **文件2** | P列(15) | N列(13) | AL列(37) | 无责任人，需记忆 |
| **文件3** | S列(18) 或 V列(21) | Q列(16) 或 T列(19) | BM列(64) | 根据M/L列筛选来源 |
| **文件4** | U列(20) | V列(21) | AT列(45) | 无 |
| **文件5** | V列(21) | N列(13) | W列(22) | 无 |
| **文件6** | L列(11) | J列(9) | N列(13) | 无 |

**文件3的判定逻辑**:
```python
# 文件3最终汇总逻辑
group1 = process1 & process2 & process3 & process6  # M列筛选（process3）
group2 = process1 & process2 & process4 & process5  # L列筛选（process4)

if row in group1 and row not in group2:
    # 因M列被筛选出：V列写回文单号，T列写时间
elif row in group2 and row not in group1:
    # 因L列被筛选出：S列写回文单号，Q列写时间
elif row in both:
    # 两者都命中：优先M列逻辑（V列+T列）
```

#### 1.4 时间格式
- **写入格式**: `yyyy-mm-dd`（如 `2025-10-30`）
- **读取格式**: `mm.dd`（如 `10.30`）

#### 1.5 并发控制
```python
# 文件锁定机制
try:
    # 尝试打开文件（独占模式）
    with open(file_path, 'r+b') as f:
        # 写入数据
        write_data()
except PermissionError:
    messagebox.showerror("文件占用", "有其他用户占用该文件，请稍后再试")
```

---

### 需求2: 任务指派功能

#### 2.1 触发条件
- **角色**: 接口工程师、室主任（一室/二室/建筑总图室）
- **时机**: 
  - 手动处理：点击"开始筛选"完成后
  - 自动处理：导出结果弹窗后
- **条件**: 处理结果中存在责任人为空的数据

#### 2.2 检测逻辑
```python
def check_unassigned_interfaces():
    """检测所有待处理文件中没有责任人的数据"""
    unassigned_rows = []
    
    for file_type in [1, 2, 3, 4, 5, 6]:
        df = get_processed_result(file_type)
        if df.empty:
            continue
        
        # 筛选责任人为空的数据
        mask = (df['责任人'].isna()) | (df['责任人'].astype(str).str.strip() == '')
        unassigned = df[mask]
        
        # 只保留当前角色职责范围内的数据
        if is_interface_engineer():
            # 接口工程师：只看自己负责的项目号
            unassigned = unassigned[unassigned['项目号'] == my_project_id]
        elif is_director():
            # 室主任：只看自己科室的数据（含"请室主任确认"）
            unassigned = unassigned[unassigned['科室'].isin([my_department, '请室主任确认'])]
        
        unassigned_rows.extend(unassigned.to_dict('records'))
    
    return unassigned_rows
```

#### 2.3 提醒弹窗
```
┌──────────────────────────────────┐
│      任务指派提醒                 │
├──────────────────────────────────┤
│ 您有 5 个需要指派的接口任务       │
│ 请注意                           │
│                                  │
│   [现在指派]  [取消]             │
└──────────────────────────────────┘
```

#### 2.4 指派界面
```
┌────────────────────────────────────────────┐
│      任务指派                              │
├────────────────────────────────────────────┤
│ 项目号 | 接口号    | 指派人              │
├────────┼───────────┼────────────────────┤
│ 2016   | INT-001   | [▼ 王任超]         │
│ 2016   | INT-002   | [▼ 李四]           │
│ 2026   | INT-003   | [▼ ]               │
│        |           |  (例如：王任超)     │
└────────────────────────────────────────────┘
│                                            │
│   [确认指派]  [取消]                       │
└────────────────────────────────────────────┘
```

#### 2.5 下拉选择功能
- **数据源**: `excel_bin/姓名角色表.xlsx` 第一列（姓名）
- **实时搜索**: 
  - 输入"王" → 显示所有姓"王"的
  - 输入"王任" → 显示所有"王任"开头的
  - 输入"超" → 显示所有包含"超"的
- **灰色提示**: "例如：王任超"

#### 2.6 数据写入

**文件2的记忆功能**:
```python
# 缓存结构 (file_cache.json)
{
  "interface_memory": {
    "2016_INT-001": "王任超",  # 项目号_接口号 → 上次指派人
    "2016_INT-002": "李四"
  }
}

# 指派时逻辑
if file_type == 2:  # 文件2无责任人列
    # 检查是否有记忆
    cache_key = f"{project_id}_{interface_id}"
    remembered_name = interface_memory.get(cache_key, "")
    
    # 预填充到下拉框
    dropdown.set(remembered_name)
    
    # 用户确认指派后，更新记忆
    interface_memory[cache_key] = assigned_name
```

**其他文件的写入**:
```python
# 写入到Excel文件的责任人列
write_to_excel(file_path, row_index, responsible_column, assigned_name)

# 责任人列位置
file1: R列(17)
file2: 无（使用记忆功能）
file3: AP列(41)
file4: AH列(33)
file5: K列(10)
file6: X列(23)
```

#### 2.7 "指派任务"按钮
- **位置**: 主界面最下端（状态栏上方）
- **显示条件**: 用户点击过"取消"关闭了指派弹窗
- **功能**: 随时重新打开指派界面

---

### 需求3: 责任人列显示

#### 3.1 列位置
```
主显示窗列顺序：
状态 | 项目号 | 接口号 | 接口时间 | 责任人 | 是否已完成
⚠️  | 2016  | INT-001| 10.28    | 王任超  | ☐
```

#### 3.2 数据源

| 文件 | 责任人列位置 | 读取逻辑 |
|------|------------|---------|
| **文件1** | R列(17) | 提取中文字符 |
| **文件2** | 无 | 显示"无"（需指派） |
| **文件3** | AP列(41) | 提取中文字符 |
| **文件4** | AH列(33) | 提取中文字符 |
| **文件5** | K列(10) | 提取中文字符 |
| **文件6** | X列(23) | 按分隔符拆分，多人用逗号连接 |

**提取逻辑**（已实现）:
```python
# 文件1为例 (main.py 第454-465行)
zh_pattern = re.compile(r"[\u4e00-\u9fa5]+")
owners = []
for idx in result_df.index:
    cell_val = df.iloc[idx, 17] if 17 < len(df.columns) else None
    s = str(cell_val) if cell_val is not None else ""
    found = zh_pattern.findall(s)
    owners.append("".join(found))
result_df['责任人'] = owners
```

#### 3.3 匹配逻辑
```python
# 角色筛选时，检查责任人是否包含用户姓名
# 支持单人和多人责任人

# 单人责任人（文件1/3/4/5）
if user_name in responsible_person:
    # 匹配

# 多人责任人（文件6）
responsible_names = responsible_person.split(',')
if user_name in responsible_names:
    # 匹配
```

---

### 需求4: 指派追踪功能

#### 4.1 业务场景
```
接口工程师/室主任指派任务后：
1. 任务分配给设计人员（王任超）
2. 设计人员完成后填写回文单号
3. 接口工程师/室主任需要追踪进度
```

#### 4.2 追踪逻辑设计

**方案A: 基于回复时间列检测**
```python
# 检测逻辑
if has_responsible_person and has_reply_time:
    status = "已完成"
elif has_responsible_person and no_reply_time:
    status = "待完成"
else:
    status = "未指派"
```

**回复时间列位置**:
- 文件1: N列(13) - 回文单号时间
- 文件2: N列(13)
- 文件3: Q列(16) 或 T列(19) - 根据L/M列
- 文件4: V列(21)
- 文件5: N列(13)
- 文件6: J列(9)

**显示方式**（建议）:
```
状态 | 项目号 | 接口号 | 责任人 | 指派状态 | 接口时间
⚠️  | 2016  | INT-001| 王任超  | 待完成   | 10.28
✅   | 2016  | INT-002| 李四    | 已完成   | 10.29
```

**筛选逻辑**:
```python
def get_assigned_tasks_status(role):
    """获取已指派任务的状态"""
    assigned_tasks = []
    
    for file_type in [1, 2, 3, 4, 5, 6]:
        df = get_processed_result(file_type)
        if df.empty:
            continue
        
        # 只看有责任人的数据（已指派）
        has_responsible = (df['责任人'].notna()) & (df['责任人'].astype(str).str.strip() != '')
        df_assigned = df[has_responsible]
        
        # 判断是否完成（回复时间列有值）
        reply_time_col = get_reply_time_column(file_type)
        df_assigned['指派状态'] = df_assigned[reply_time_col].apply(
            lambda x: "已完成" if pd.notna(x) and str(x).strip() != '' else "待完成"
        )
        
        assigned_tasks.extend(df_assigned.to_dict('records'))
    
    return assigned_tasks
```

---

## 技术实现方案

### 模块架构

```
新增模块:
├── input_handler.py       # 回文单号输入处理
│   ├── InterfaceInputDialog      # 输入弹窗类
│   ├── write_response_to_excel() # 写入Excel函数
│   └── get_write_columns()       # 获取写入列位置
│
├── distribution.py        # 任务指派处理
│   ├── AssignmentDialog          # 指派界面类
│   ├── check_unassigned()        # 检测未指派任务
│   ├── get_name_list()           # 获取姓名列表
│   └── save_assignment()         # 保存指派结果
│
修改模块:
├── window.py
│   ├── 添加接口号点击事件绑定
│   ├── 添加责任人列显示
│   └── 添加"指派任务"按钮
│
├── base.py
│   ├── 集成input_handler调用
│   ├── 集成distribution调用
│   ├── 添加指派检测逻辑
│   └── 添加追踪功能入口
│
├── file_manager.py
│   └── 添加interface_memory缓存
│
├── excel_processor.spec
│   └── 更新打包配置
```

### 核心函数设计

#### input_handler.py
```python
class InterfaceInputDialog(tk.Toplevel):
    """回文单号输入弹窗"""
    
    def __init__(self, parent, interface_id, file_type, file_path, row_index, user_name):
        """
        参数:
            parent: 父窗口
            interface_id: 接口号
            file_type: 文件类型(1-6)
            file_path: 原始Excel文件路径
            row_index: Excel行号
            user_name: 当前用户姓名
        """
        # 创建输入界面
        # 绑定确认/取消按钮
        
    def on_confirm(self):
        """确认按钮回调"""
        response_number = self.entry.get().strip()
        if not response_number:
            messagebox.showwarning("警告", "请输入回文单号")
            return
        
        # 写入Excel
        success = write_response_to_excel(
            self.file_path,
            self.file_type,
            self.row_index,
            response_number,
            self.user_name
        )
        
        if success:
            messagebox.showinfo("成功", "回文单号已保存")
            self.destroy()
        else:
            messagebox.showerror("失败", "保存失败，请重试")

def write_response_to_excel(file_path, file_type, row_index, response_number, user_name):
    """
    写入回文单号到Excel文件
    
    返回:
        bool: 成功返回True，失败返回False
    """
    try:
        # 文件锁定检测
        with open(file_path, 'r+b') as f:
            # 使用openpyxl打开
            wb = load_workbook(file_path)
            ws = wb.active
            
            # 获取写入列位置
            columns = get_write_columns(file_type, row_index, ws)
            
            # 写入数据
            ws[f"{columns['response_col']}{row_index}"] = response_number
            ws[f"{columns['time_col']}{row_index}"] = date.today().strftime('%Y-%m-%d')
            ws[f"{columns['name_col']}{row_index}"] = user_name
            
            # 保存
            wb.save(file_path)
            return True
            
    except PermissionError:
        messagebox.showerror("文件占用", "有其他用户占用该文件，请稍后再试")
        return False
    except Exception as e:
        print(f"写入失败: {e}")
        return False

def get_write_columns(file_type, row_index, worksheet):
    """
    获取各文件类型的写入列位置
    
    对于文件3，需要判断是M列还是L列筛选
    """
    if file_type == 3:
        # 文件3特殊逻辑：判断M列或L列
        m_col = worksheet[f"M{row_index}"].value
        l_col = worksheet[f"L{row_index}"].value
        
        # 检查process3条件（M列时间）
        # 检查process4条件（L列时间）
        # ... 判断逻辑 ...
        
        if is_m_column_source:
            return {'response_col': 'V', 'time_col': 'T', 'name_col': 'BM'}
        else:
            return {'response_col': 'S', 'time_col': 'Q', 'name_col': 'BM'}
    
    # 其他文件类型的固定列位置
    column_map = {
        1: {'response_col': 'S', 'time_col': 'N', 'name_col': 'V'},
        2: {'response_col': 'P', 'time_col': 'N', 'name_col': 'AL'},
        4: {'response_col': 'U', 'time_col': 'V', 'name_col': 'AT'},
        5: {'response_col': 'V', 'time_col': 'N', 'name_col': 'W'},
        6: {'response_col': 'L', 'time_col': 'J', 'name_col': 'N'},
    }
    
    return column_map[file_type]
```

#### distribution.py
```python
class AssignmentDialog(tk.Toplevel):
    """任务指派界面"""
    
    def __init__(self, parent, unassigned_tasks, file_manager, name_list):
        """
        参数:
            parent: 父窗口
            unassigned_tasks: 未指派任务列表
            file_manager: 文件管理器（用于记忆功能）
            name_list: 姓名列表（从姓名角色表读取）
        """
        # 创建Treeview显示任务列表
        # 为每行添加Combobox下拉选择
        # 支持实时搜索过滤
        
    def on_search(self, event, combobox):
        """实时搜索回调"""
        search_text = combobox.get().strip()
        if not search_text:
            combobox['values'] = self.name_list
            return
        
        # 过滤姓名列表
        filtered = [name for name in self.name_list if search_text in name]
        combobox['values'] = filtered
        
    def on_confirm(self):
        """确认指派按钮回调"""
        assignments = self.get_all_assignments()
        
        for assignment in assignments:
            save_assignment(
                assignment['file_type'],
                assignment['file_path'],
                assignment['row_index'],
                assignment['assigned_name'],
                self.file_manager
            )
        
        messagebox.showinfo("成功", f"已指派 {len(assignments)} 个任务")
        self.destroy()

def check_unassigned(processed_results, user_roles, project_id=None):
    """
    检测所有处理结果中没有责任人的数据
    
    参数:
        processed_results: 6个文件的处理结果字典
        user_roles: 当前用户角色列表
        project_id: 项目号（接口工程师需要）
    
    返回:
        list: 未指派任务列表
    """
    unassigned = []
    
    for file_type, df in processed_results.items():
        if df is None or df.empty:
            continue
        
        # 筛选责任人为空
        mask = (df['责任人'].isna()) | (df['责任人'].astype(str).str.strip() == '')
        df_unassigned = df[mask]
        
        # 角色权限过滤
        if is_interface_engineer(user_roles):
            # 只看自己负责的项目
            df_unassigned = df_unassigned[df_unassigned['项目号'] == project_id]
        elif is_director(user_roles):
            # 只看自己科室的数据
            my_department = get_department(user_roles)
            df_unassigned = df_unassigned[df_unassigned['科室'].isin([my_department, '请室主任确认'])]
        
        # 转换为字典列表
        for idx, row in df_unassigned.iterrows():
            unassigned.append({
                'file_type': file_type,
                'project_id': row['项目号'],
                'interface_id': row['接口号'],
                'file_path': row.get('source_file', ''),
                'row_index': row.get('原始行号', 0)
            })
    
    return unassigned

def get_name_list():
    """从姓名角色表读取姓名列表"""
    try:
        xls_path = get_resource_path("excel_bin/姓名角色表.xlsx")
        df = pd.read_excel(xls_path)
        # 第一列为姓名
        names = df.iloc[:, 0].dropna().astype(str).tolist()
        return sorted(set(names))  # 去重排序
    except Exception as e:
        print(f"读取姓名列表失败: {e}")
        return []

def save_assignment(file_type, file_path, row_index, assigned_name, file_manager):
    """
    保存指派结果
    
    - 文件2: 保存到缓存记忆
    - 其他文件: 写入Excel责任人列
    """
    if file_type == 2:
        # 文件2特殊处理：保存记忆
        # 读取接口号
        interface_id = get_interface_id(file_path, row_index)
        cache_key = f"{project_id}_{interface_id}"
        file_manager.save_interface_memory(cache_key, assigned_name)
    else:
        # 写入Excel
        responsible_col = get_responsible_column(file_type)
        write_to_excel(file_path, row_index, responsible_col, assigned_name)
```

---

## 数据流转设计

### 流程1: 回文单号输入

```
用户点击接口号
  ↓
获取: file_type, file_path, row_index, interface_id
  ↓
弹出InterfaceInputDialog
  ↓
用户输入回文单号 + 点击确认
  ↓
write_response_to_excel()
  ├─ 检查文件锁定
  ├─ 打开Excel文件
  ├─ 获取写入列位置（文件3需判断M/L）
  ├─ 写入：回文单号、时间(yyyy-mm-dd)、姓名
  └─ 保存文件
  ↓
刷新显示（可选）/ 提示成功
```

### 流程2: 任务指派

```
用户完成筛选
  ↓
check_unassigned() 检测
  ├─ 遍历6个文件的处理结果
  ├─ 筛选责任人为空的数据
  ├─ 应用角色权限过滤
  └─ 返回未指派任务列表
  ↓
如果有未指派任务:
  ├─ 弹出提醒弹窗
  ├─ 用户选择"现在指派" or "取消"
  ├─ "现在指派" → 打开AssignmentDialog
  └─ "取消" → 显示"指派任务"按钮
  ↓
AssignmentDialog:
  ├─ 显示任务列表（项目号、接口号）
  ├─ 为每行添加Combobox（姓名下拉）
  ├─ 支持实时搜索
  ├─ 文件2自动填充记忆值
  └─ 用户选择 + 确认
  ↓
save_assignment() 保存
  ├─ 文件2 → 保存到缓存记忆
  └─ 其他文件 → 写入Excel责任人列
  ↓
更新缓存 / 刷新显示
```

### 流程3: 指派追踪

```
接口工程师/室主任查看数据
  ↓
筛选条件：有责任人的数据
  ↓
新增"指派状态"列:
  ├─ 检查回复时间列
  ├─ 有值 → "已完成" ✅
  └─ 无值 → "待完成" ⏳
  ↓
显示：项目号 | 接口号 | 责任人 | 指派状态 | 接口时间
```

---

## 关键逻辑说明

### 逻辑1: 文件3的M列/L列判断

**背景**:
```python
# 文件3最终汇总逻辑（main.py 第1422-1425行）
group1 = process1 & process2 & process3 & process6  # M列筛选路径
group2 = process1 & process2 & process4 & process5  # L列筛选路径
final_rows = group1 | group2
```

**判断方法**:
```python
def determine_file3_source(row_index, worksheet):
    """
    判断文件3某行是因M列还是L列被筛选出
    
    返回: 'M' 或 'L'
    """
    # 方法1: 重新执行筛选逻辑判断
    # 读取该行数据
    row_data = worksheet[row_index]
    
    # 检查process3条件（M列）
    m_val = row_data[12].value  # M列
    t_val = row_data[19].value  # T列
    
    m_match = check_time_condition(m_val) and is_empty(t_val)
    
    # 检查process4条件（L列）
    l_val = row_data[11].value  # L列
    q_val = row_data[16].value  # Q列
    
    l_match = check_time_condition(l_val) and is_empty(q_val)
    
    # 优先级：如果两者都匹配，优先M列
    if m_match:
        return 'M'
    elif l_match:
        return 'L'
    else:
        return 'M'  # 默认M列
```

**简化方案**（推荐）:
```python
# 在process_target_file3()中，为每行添加来源标记
result_df['_source_column'] = 'M'  # 或 'L'

# 根据group1和group2判断
for idx in final_indices:
    if idx in group1 and idx not in group2:
        source_map[idx] = 'M'
    elif idx in group2 and idx not in group1:
        source_map[idx] = 'L'
    else:
        source_map[idx] = 'M'  # 两者都匹配，优先M
```

### 逻辑2: 文件2的记忆功能

**缓存结构**:
```json
{
  "interface_memory": {
    "2016_INT-001": "王任超",
    "2026_INT-002": "李四"
  }
}
```

**读取记忆**:
```python
def get_remembered_assignment(project_id, interface_id):
    cache_key = f"{project_id}_{interface_id}"
    return interface_memory.get(cache_key, "")
```

**保存记忆**:
```python
def save_interface_memory(project_id, interface_id, assigned_name):
    cache_key = f"{project_id}_{interface_id}"
    interface_memory[cache_key] = assigned_name
    file_manager.save_cache()  # 持久化
```

### 逻辑3: 角色权限过滤

**接口工程师**:
```python
# 只看自己负责的项目号
engineer_project = parse_interface_engineer_role(role)  # 如 "2016"
df_filtered = df[df['项目号'] == engineer_project]
```

**室主任**:
```python
# 只看自己科室的数据
if role == '一室主任':
    df_filtered = df[df['科室'].isin(['结构一室', '请室主任确认'])]
elif role == '二室主任':
    df_filtered = df[df['科室'].isin(['结构二室', '请室主任确认'])]
elif role == '建筑总图室主任':
    df_filtered = df[df['科室'].isin(['建筑总图室', '请室主任确认'])]
```

---

## 测试要求

### 测试用例清单

#### 功能1: 回文单号输入

| 测试项 | 测试场景 | 预期结果 |
|-------|---------|---------|
| TC-001 | 点击接口号触发弹窗 | 弹窗正常显示 |
| TC-002 | 输入回文单号并确认 | 数据成功写入Excel |
| TC-003 | 时间格式验证 | 时间以`yyyy-mm-dd`格式写入 |
| TC-004 | 文件1写入位置 | S/N/V列正确 |
| TC-005 | 文件2写入位置 | P/N/AL列正确 |
| TC-006 | 文件3-M列来源 | V/T/BM列正确 |
| TC-007 | 文件3-L列来源 | S/Q/BM列正确 |
| TC-008 | 文件4写入位置 | U/V/AT列正确 |
| TC-009 | 文件5写入位置 | V/N/W列正确 |
| TC-010 | 文件6写入位置 | L/J/N列正确 |
| TC-011 | 并发写入测试 | 第二个用户收到"文件占用"提示 |
| TC-012 | 空输入验证 | 提示"请输入回文单号" |

#### 功能2: 任务指派

| 测试项 | 测试场景 | 预期结果 |
|-------|---------|---------|
| TC-013 | 检测未指派任务 | 正确识别责任人为空的数据 |
| TC-014 | 接口工程师权限 | 只看到自己项目的未指派任务 |
| TC-015 | 室主任权限 | 只看到自己科室的未指派任务 |
| TC-016 | 提醒弹窗显示 | 显示正确的未指派任务数量 |
| TC-017 | 指派界面显示 | 正确显示项目号、接口号 |
| TC-018 | 下拉列表数据 | 姓名列表与姓名角色表一致 |
| TC-019 | 实时搜索功能 | 输入"王"显示所有"王"开头的 |
| TC-020 | 文件2记忆功能 | 自动填充上次指派的姓名 |
| TC-021 | 指派保存-文件1 | 正确写入R列 |
| TC-022 | 指派保存-文件3 | 正确写入AP列 |
| TC-023 | 指派保存-文件4 | 正确写入AH列 |
| TC-024 | 指派保存-文件5 | 正确写入K列 |
| TC-025 | 指派保存-文件6 | 正确写入X列 |
| TC-026 | 点击"取消"按钮 | "指派任务"按钮显示 |
| TC-027 | "指派任务"按钮功能 | 重新打开指派界面 |

#### 功能3: 责任人列显示

| 测试项 | 测试场景 | 预期结果 |
|-------|---------|---------|
| TC-028 | 文件1责任人显示 | 从R列读取并显示 |
| TC-029 | 文件2责任人显示 | 显示"无" |
| TC-030 | 文件3责任人显示 | 从AP列读取并显示 |
| TC-031 | 文件4责任人显示 | 从AH列读取并显示 |
| TC-032 | 文件5责任人显示 | 从K列读取并显示 |
| TC-033 | 文件6责任人显示 | 从X列读取，多人用逗号连接 |
| TC-034 | 空值处理 | 显示"无" |
| TC-035 | 列宽设置 | 责任人列宽度合适 |
| TC-036 | 列顺序 | 状态|项目号|接口号|接口时间|责任人|完成 |

#### 功能4: 指派追踪

| 测试项 | 测试场景 | 预期结果 |
|-------|---------|---------|
| TC-037 | 追踪已指派任务 | 正确显示有责任人的数据 |
| TC-038 | 已完成判断 | 回复时间有值显示"已完成" |
| TC-039 | 待完成判断 | 回复时间无值显示"待完成" |
| TC-040 | 追踪界面显示 | 显示完整信息 |

#### 集成测试

| 测试项 | 测试场景 | 预期结果 |
|-------|---------|---------|
| TC-041 | 手动模式完整流程 | 筛选→指派→输入→追踪 |
| TC-042 | 自动模式完整流程 | 自动筛选→指派提醒→指派 |
| TC-043 | 缓存一致性 | 所有操作后缓存正确 |
| TC-044 | 打包后功能验证 | EXE中所有功能正常 |

---

## 附录

### 附录A: Excel列索引对照表

| 列名 | 索引 | 列名 | 索引 | 列名 | 索引 |
|-----|------|-----|------|-----|------|
| A | 0 | N | 13 | AL | 37 |
| I | 8 | P | 15 | AP | 41 |
| J | 9 | Q | 16 | AH | 33 |
| K | 10 | R | 17 | AT | 45 |
| L | 11 | S | 18 | BM | 64 |
| M | 12 | T | 19 | X | 23 |

### 附录B: 文件类型映射

```python
FILE_TYPE_MAP = {
    1: "内部需打开接口",
    2: "内部需回复接口",
    3: "外部需打开接口",
    4: "外部需回复接口",
    5: "三维提资接口",
    6: "收发文函"
}
```

### 附录C: 姓名角色表格式

```
| 姓名   | 角色             |
|--------|------------------|
| 王任超 | 设计人员         |
| 李四   | 设计人员         |
| 张三   | 一室主任         |
| 赵六   | 2016接口工程师   |
```

---

**文档完成，所有需求已详细说明！**

