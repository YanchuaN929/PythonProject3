# 性能优化：加载缓存流程冗余分析（基于终端输出@Python 660-1008）

> 目标：在“文件未变化且缓存命中”的常见场景下，进一步降低 **无意义的Excel IO / Registry写入 / 重复UI渲染与过滤**，让“点开始处理”接近“秒开”。
>
> 本文仅做原因分析与优化建议，不直接改动代码逻辑（除非你确认方案后再动手）。

---

## 1. 本次终端输出的关键事实（证据）

在你的日志中同时出现了：

- **并发预加载Excel**（但随后仍走缓存）
  - `🚀 开始并发预加载Excel文件...`
- **缓存命中**
  - `🔍 检查文件标识和缓存...`
  - `✅ 文件未变化，尝试加载缓存...`
  - `✅ 成功加载 26 个缓存结果`
- **随后仍执行“开始批量处理 file1~6”，并对每个项目打印“✅ 使用缓存”**
  - `开始批量处理文件1类型，共 7 个文件`
  - `✅ 使用缓存: 项目1907file1 (37行)`（大量类似行）
- **UI层超期/显示过滤重复出现多次**
  - ` [超期过滤] 文件2: 隐藏287个超期>30工作日的任务 (337→50行)` 出现不止一次
  - ` [超期过滤] 文件3: 隐藏4个超期>30工作日的任务 (48→44行)` 出现不止一次
  - `外部需打开接口 - 按接口时间列排序（降序）` 也重复

**结论**：在“缓存已加载+文件未变化”的场景里，当前流程仍然执行了多段本可跳过的工作。

---

## 2. 终端输出对应到代码的调用链（定位）

结合 `base.py` 的实现，本次流程大致是：

1. `refresh_file_list()`（你点击“刷新文件列表”触发）
2. `identify_target_files()`：识别各类型文件
3. `identify_target_files()` **无条件执行并发预加载**（方案3）
   - 位置：`base.py` 里 `identify_target_files` 末尾有 `print("\n🚀 开始并发预加载Excel文件...")`
4. `refresh_file_list()` 内部调用 `_check_and_load_cache()`
   - 位置：`base.py::_check_and_load_cache` 打印 `🔍 检查文件标识和缓存...`
   - 行为：对 file1~6 逐个项目 `load_cached_result(...)`，并把结果写入 `processing_results_multiX`
5. 你随后点击 “开始处理” -> `start_processing()`
6. `start_processing()` 内部开启后台线程 `process_files()`，对 file1~6 做“批量处理”
   - 关键点：每个 fileX 批量处理开头会 **清空 `self.processing_results_multiX = {}`**
   - 然后再次调用 `_process_with_cache(...)`，又会 `load_cached_result(...)` 一遍（缓存命中打印“✅ 使用缓存”）
7. 处理结束后 `update_display()`：
   - **无条件**调用 `registry_hooks.on_scan_finalize(...)`
   - 对每个 resultsX 调用 `display_resultsX(...)`（渲染+过滤）
   - `notebook.select(active_tab)` 触发 `on_tab_changed`，**可能再次触发 display_resultsX**，导致过滤/排序重复打印

### 2.1 你提出的问题1：`identify_target_files()` 的并发预加载是否关联“主显示窗”？

**有直接关联，但仅影响“未开始处理/未有处理结果时”的原始预览显示，不影响“处理结果显示”。**

证据（来自 `base.py::on_tab_changed` 的显示分支，逻辑是“优先处理结果，否则原始预览”）：

- 当某个 tab 对应类型 **没有已处理结果** 时（`has_processed_resultsX == False`）：
  - 若 `self.fileX_data` 已经存在（由并发预加载或 `load_file_to_viewer()` 读入），会走 `display_excel_data(viewer, self.fileX_data, tab_name)` 展示 **原始数据预览**；
  - 否则才会走 `load_file_to_viewer(self.target_fileX, ...)` 现读现显。

因此：

- **如果我们“完全移除预加载”**：不会影响处理结果的显示，但会让用户在“未处理状态切 tab 查看原始内容”时，首次切换更慢（因为改成按需读取）。
- **更安全的优化方式**是“条件化预加载”：仅在确实需要原始预览时才预加载；或者完全按需读取但保证 `load_file_to_viewer()` 路径稳定。

---

## 3. 明确的“多余逻辑”清单（按收益排序）

### 3.1 冗余1：无条件“并发预加载Excel文件”

**现象**：即使后续缓存已命中（`✅ 成功加载 26 个缓存结果`），仍提前读取了若干Excel（你日志里只显示读完了部分文件，但IO已发生）。

**代码根因**：`identify_target_files()` 末尾的“方案3”块，无条件执行预加载（通常读取每类的第一个文件）。

**为什么多余/有害**：
- 缓存命中时，`start_processing()`主要从 `.pkl` 缓存读结果，不需要这些“预读出来的DataFrame”。
- 网络盘/大Excel时，预加载会抢占IO，拖慢“用户可感知的第一屏响应”。

**优化建议（优先）**：
- **条件化预加载（推荐，兼顾显示体验与速度）**：
  - 仅当“该文件类型在 UI 处于**未处理状态**（`has_processed_resultsX == False`）且用户确实可能看原始预览”时，才预加载该类型的首个文件；
  - 如果 `_check_and_load_cache()` 已经成功加载了该类型的缓存结果（即用户下一步大概率要看处理结果），则 **跳过**该类型的原始预加载。
- **或者改为纯按需加载（更极致的速度，稍影响体验）**：
  - 不预加载，用户切 tab 时由 `load_file_to_viewer()` 现读现显。

> 安全性说明：无论采用哪种，只要保留 `load_file_to_viewer()` 分支，**不会影响处理结果显示**；影响的只是“未处理时看原始预览”的响应方式。

---

### 3.2 冗余2：“刷新阶段已加载缓存” + “开始处理阶段再次加载缓存”

**现象**：你日志里先 `✅ 成功加载 26 个缓存结果`，然后又进入 `开始批量处理文件1类型...` 并对每个项目打印 `✅ 使用缓存...`。

**代码根因**：
- `_check_and_load_cache()` 已经把缓存结果放进 `processing_results_multiX`；
- 但 `start_processing()` 在每个 fileX 开头又把 `self.processing_results_multiX = {}` 重置掉，并重新 `_process_with_cache()`。

**为什么多余**：
- 在“文件未变化+缓存命中”场景，二次 `load_cached_result` 纯粹重复IO（虽然比读Excel快，但仍是磁盘IO+反序列化开销）。

**优化建议（高收益）**：
给 `start_processing()` 增加一个“缓存复用快路径”：
- 条件（关键：**必须是“按文件粒度”判定变化**，不是全局一刀切）：
  - 基于 `file_manager.get_changed_files(all_file_paths)` 得到的 `changed_files` 集合；对每个 fileX/每个项目对应的 `file_path`：
    - 若该 `file_path` **不在** `changed_files`，则视为“未变化文件”；
    - 若该 `file_path` **在** `changed_files`，则该文件仍需走原流程（清缓存/重处理/写Registry，取决于你的业务约束）。
  - 且本轮在 `refresh_file_list()->_check_and_load_cache()` 已经成功加载过缓存（最好记录一个“缓存加载快照”，例如：时间戳 + all_file_paths 指纹 + 成功加载数量）。
  - 且当前 fileX 对应的 `processing_results_multiX` 已经存在（避免误跳过导致空窗）。
- 动作：
  - 对“未变化文件”：**跳过** per-project 循环与 `_process_with_cache()`（避免重复 `load_cached_result`）；
  - 对“变化文件”或“缓存缺失文件”（某些项目缓存不存在、会触发真实读Excel的情况）：只处理这些目标（增量处理）。

这样“刷新->开始处理”就不会重复读缓存。

> 安全性说明：这条优化的关键是“只跳过未变化且已有结果的部分”，因此不会影响显示；相反，它会减少你日志里大量的 `✅ 使用缓存: 项目...` 重复出现。

---

### 3.3 冗余3：缓存命中也做 Registry 全量 on_process_done + on_scan_finalize

**现象**：大量
- `[INFO] Registry: 文件X项目YYYY写入N个任务`
- 以及 `scan_finalize: batch=...`

即使你本次是“文件未变化 + 使用缓存”。

**代码根因**：
`start_processing()` 的批量处理对每个 fileX 都：
- 构建 `raw_results_for_registry`
- `registry_hooks.on_process_done(...)`
并且 `update_display()` 无条件 `on_scan_finalize(...)`。

**为什么可能是多余**：
如果源Excel未变化，Registry 上次扫描结果理论上仍有效；
重复写入 + finalize 在网络盘/SQLite 上会引入锁竞争、IO、以及大量业务判断（你日志里 file2 有大量“预期时间变化，重置状态”的输出）。

**你给出的业务约束（已确认）**：

- 当“源Excel未变化”时，本次运行 **允许不触发任何 registry 写入与 finalize**；
- `missing` 归档（`scan_finalize`）的频率：**只有当“管理员角色”运行开始处理时才执行**。

基于此，优化建议需要改成更严格、更安全的版本：

- **Registry on_process_done：按文件/按项目增量触发**
  - 仅对满足任一条件的项目调用：
    - 该项目对应 `file_path` 在 `changed_files` 中（源Excel确实变化）；
    - 或该项目本次发生了“缓存未命中 -> 实际读取Excel并重新计算”（即真实新鲜结果），避免 Registry 长期不更新。
  - 对于“缓存命中 + 文件未变化”的项目：跳过 `on_process_done`（纯重复写入，且你已允许跳过）。

- **Registry on_scan_finalize：角色门禁**
  - 仅当 `("管理员" in user_roles)` 且（本轮确实做过增量 `on_process_done` 或检测到 `changed_files` 非空）时才执行；
  - 非管理员运行：即使开始处理，也 **不执行 finalize**（符合你给出的频率要求）。

> 这条优化对速度提升很大，但涉及“Registry是否必须每次运行都刷新”的业务约束，需要你确认期望一致性（例如：是否依赖每次运行来清理missing/归档）。

#### 3.3.1 你提出的问题3：会不会影响“新增的显示缓存/显示逻辑”？

需要分两类依赖看：

- **显示缓存本身（`.pkl` + `processing_results_multiX`）**：
  - 它来自 `file_manager.load_cached_result(...)` 与内存字典，**不依赖 Registry**。
  - 因此“跳过 Registry 写入/finalize”不会让“缓存显示”失效。

- **显示过滤中“查询Registry状态”的部分**（例如“待审查/待确认过滤”、“超期过滤”等）：
  - 这些过滤逻辑通常是在 `display_resultsX` 中查询 registry 任务状态以决定是否展示/隐藏；
  - 在你确认的规则下：
    - 源Excel未变化时跳过写入：Registry 中的状态仍是“上一次扫描的稳定状态”，显示不会崩；
    - missing 归档只在管理员执行：非管理员看到的“missing清理”可能**不及时**（但这是你明确接受的业务策略）。

结论：**对显示安全**，但需要在文档中明确“非管理员不做missing归档带来的可见性差异”，避免误解。

---

### 3.4 冗余4：UI过滤/渲染多次触发（超期过滤日志重复）

**现象**：
同一个 file2/file3 的
- `[超期过滤] ...`
- `[显示过滤] ...`
在一次运行尾部重复出现多次；以及排序日志重复。

**代码根因（组合效应）**：
1) `update_display()` 对每个 fileX 都调用一次 `display_resultsX(...)`；
2) `update_display()` 末尾 `notebook.select(active_tab)` 会触发 `<<NotebookTabChanged>>` -> `on_tab_changed()`；
3) `on_tab_changed()` 又会再次调用 `display_results2/3/4/5/6`（至少对当前tab），导致过滤/排序重复；
4) 某些显示路径还会再触发 `refresh_current_tab_display()`（在刷新文件列表完成后也会调用）。

**优化建议（中高收益，风险低）**：
让“处理完成后的渲染”只发生一次：
- 方案A（推荐）：`update_display()` 只渲染 **active_tab**（当前要看的那一页），其他 tab 等用户切换时再渲染
- 方案B：在 `notebook.select(active_tab)` 前临时屏蔽 `on_tab_changed`（设置一个 `_suppress_tab_change_render=True` 标志），避免“程序选择tab”导致二次渲染
- 方案C：`update_display()` 不直接调用 `display_resultsX`，只更新状态/数据，然后 `notebook.select(active_tab)` 后让 `on_tab_changed()` 渲染一次即可

此外，“统计弹窗的 display_count”当前通过 `_exclude_pending_confirmation_rows(results.copy(), ...)` 重新跑一遍过滤来计算数量，也属于重复计算；更快的方式是 **复用 display_resultsX 内已经得到的最终显示df** 来计数。

---

## 4. 推荐的落地顺序（最大化收益/最小化风险）

### 第一步（低风险，高收益）
- **移除/条件化** `identify_target_files()` 的无条件预加载（缓存命中时不预读Excel）
- **避免“刷新加载缓存”与“开始处理再次加载缓存”重复**：引入 start_processing 的缓存复用快路径

### 第二步（中风险，最高收益）
- Registry 改为增量更新（按你的业务约束落地）：
  - 只在“文件变更/缓存未命中”时 `on_process_done`
  - `on_scan_finalize` 增加 **管理员角色门禁**（仅管理员开始处理时触发）

### 第三步（低风险，中收益）
- 合并UI渲染路径：避免 `update_display()` 与 `on_tab_changed()` 双重渲染，消除重复超期过滤/排序

---

## 5. 你可以用来验证优化效果的观测指标

建议每次改动后对比以下日志是否消失/减少：
- `🚀 开始并发预加载Excel文件...`（缓存命中场景应消失）
- `✅ 成功加载 XX 个缓存结果` 之后，不应再出现大量 `✅ 使用缓存: 项目...`
- `[INFO] Registry: 文件X项目...写入...` 在“未变化+缓存命中”场景应显著减少或为0（取决于你确认的业务要求）
- `[超期过滤]` / `[显示过滤]` 在一次运行尾部每个文件类型应最多出现一次（或仅在当前tab出现一次）

---

## 6. 下一步需要你确认的两点（决定Registry优化是否可做）

1) **Registry一致性要求**：当“源Excel未变化”时，你是否允许本次运行 **不触发任何 registry 写入与 finalize**？
   - ✅ 你已确认：**允许**
2) **missing归档频率**：`scan_finalize` 是否必须“每次开始处理都执行”，还是可以“仅在源变更后/定时执行”？
   - ✅ 你已确认：**只有当管理员角色运行开始处理时才执行**

你确认后，我可以按“第一步->第二步->第三步”的顺序逐步改代码，并给每一步配一个最小pytest用例锁定行为。

---

## 7. 复核：本文修改建议是否“有效且安全”（再次自检）

结合你最新的终端片段（同一次运行里，部分项目缓存命中、部分项目发生缓存未命中而实际读Excel），可以得出更精确的安全边界：

- **3.2 的“缓存复用快路径”必须支持“部分命中、部分未命中”**：
  - 只跳过“未变化 + 已有结果”的项目；
  - 对“缓存缺失导致真实读Excel”的项目继续处理（否则会漏数据）。

- **3.3 的 Registry 增量策略也必须支持“部分命中、部分未命中”**：
  - 对“真实读Excel得到的新鲜结果”执行 `on_process_done`（即便 `changed_files` 为空，也可能存在缓存缺失/首次运行）；
  - 对“缓存命中且未变化”的部分跳过写入。

- **3.1 的预加载优化不能破坏“未处理时的原始预览体验”**：
  - 必须保留 `load_file_to_viewer()` 的按需读取路径；
  - 若你希望 tab 切换仍然顺滑，则采用“条件化预加载（仅原始预览需要时）”更稳妥。

在上述约束下，三个优化点可以做到：**速度显著提升 + 不影响主显示窗稳定性 + Registry 策略符合你的业务要求**。


