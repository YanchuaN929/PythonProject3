# Registry 工作流详解

## 一、系统概述

Registry 是一个任务状态追踪系统，用于：
1. **记录任务首次出现的时间**
2. **追踪任务状态变化**（待处理 → 待审查 → 已确认）
3. **保持状态一致性**：即使 Excel 文件变化，任务状态也不丢失

---

## 二、核心数据结构

### 任务标识（Task ID）
```
task_id = hash(file_type + project_id + interface_id + source_file + row_index)
```
- **唯一标识一条任务记录**
- row_index 变化会产生新的 task_id

### 业务标识（Business ID）
```
business_id = "file_type|project_id|interface_id"
```
- **唯一标识一个接口**（不含行号）
- 用于状态继承：即使行号变化，同一接口的状态可以继承

### 关键字段
| 字段 | 含义 | 示例值 |
|------|------|--------|
| status | 内部状态 | open / completed / confirmed / archived |
| display_status | 显示状态 | 请指派 / 待完成 / 待审查 / 已审查 |
| responsible_person | 责任人 | 张三 |
| assigned_by | 指派人 | 王工（1818接口工程师） |
| interface_time | 接口时间/答复期限 | 2025-03-15 |
| first_seen_at | 首次发现时间 | 2025-12-01T09:00:00 |
| last_seen_at | 最后出现时间 | 2025-12-05T09:00:00 |

---

## 三、第一批源文件进入时的流程

### 场景：2025年12月1日（周一），用户首次运行程序

```
用户点击"开始处理"
        ↓
┌─────────────────────────────────────┐
│  Step 1: Excel 筛选（main.py）      │
├─────────────────────────────────────┤
│ 文件2为例：                         │
│ process1: I列包含"建筑结构所"→ 880行 │
│ process2: 日期在2025年内      → 2597行│
│ process3: AB列4444开头(排除) → 52行  │
│ process4: N列为空且A列非空   → 1475行│
│                                     │
│ 最终结果 = P1 ∩ P2 ∩ P4 - P3 = 300行 │
└─────────────────────────────────────┘
        ↓
┌─────────────────────────────────────┐
│  Step 2: Registry 查询（可选）      │
├─────────────────────────────────────┤
│ 查询数据库中该文件类型的任务        │
│ 首次运行：数据库为空，跳过          │
│ final_rows = 300行                  │
└─────────────────────────────────────┘
        ↓
┌─────────────────────────────────────┐
│  Step 3: 角色筛选（base.py）        │
├─────────────────────────────────────┤
│ 根据用户角色过滤显示数据            │
│ 例如：设计人员只看责任人=自己的任务  │
│ 筛选后显示：150行                   │
└─────────────────────────────────────┘
        ↓
┌─────────────────────────────────────┐
│  Step 4: Registry 写入（hooks.py）  │
├─────────────────────────────────────┤
│ 【关键】写入的是角色筛选前的300行    │
│ 不是显示的150行                     │
│                                     │
│ on_process_done(                    │
│   file_type=2,                      │
│   project_id="1818",                │
│   source_file="内部接口...xlsx",    │
│   result_df=300行原始结果           │
│ )                                   │
└─────────────────────────────────────┘
        ↓
┌─────────────────────────────────────┐
│  Step 5: 批量 Upsert（service.py）  │
├─────────────────────────────────────┤
│ 对每一行：                          │
│ 1. 生成 task_id 和 business_id      │
│ 2. 查询是否存在同 business_id 的任务 │
│ 3. 如果存在：                       │
│    - 比较 interface_time 是否变化   │
│    - 变化则重置状态                 │
│    - 不变则继承状态                 │
│ 4. 如果不存在：                     │
│    - 创建新任务                     │
│    - display_status = '待完成'      │
│    - status = 'open'                │
│ 5. 设置 first_seen_at, last_seen_at │
└─────────────────────────────────────┘
```

### 首次运行后数据库状态

| business_id | interface_id | display_status | status | responsible_person | first_seen_at |
|-------------|--------------|----------------|--------|-------------------|---------------|
| 2\|1818\|S-XXX-01 | S-XXX-01 | 待完成 | open | 张三 | 2025-12-01 |
| 2\|1818\|S-XXX-02 | S-XXX-02 | 请指派 | open | (空) | 2025-12-01 |
| 2\|1818\|S-XXX-03 | S-XXX-03 | 待完成 | open | 李四 | 2025-12-01 |
| ... | ... | ... | ... | ... | ... |

---

## 四、用户操作引发的状态变化

### 4.1 设计人员填写回文单号

```
用户在界面上填写回文单号 "HFMR001"
        ↓
on_response_written() 被调用
        ↓
┌─────────────────────────────────────┐
│ 1. 查询该任务是否有指派人           │
│    - 有指派人 → display_status='待指派人审查'
│    - 无指派人 → display_status='待审查'
│ 2. 更新 status = 'completed'        │
│ 3. 记录 completed_by = "张三"       │
│ 4. 记录 response_number = "HFMR001" │
└─────────────────────────────────────┘
```

**数据库变化**：
| interface_id | display_status | status | response_number | completed_by |
|--------------|----------------|--------|-----------------|--------------|
| S-XXX-01 | **待审查** | **completed** | HFMR001 | 张三 |

### 4.2 上级确认任务

```
上级点击"已完成"勾选框
        ↓
on_confirmed_by_superior() 被调用
        ↓
┌─────────────────────────────────────┐
│ 1. 更新 status = 'confirmed'        │
│ 2. 更新 display_status = '已审查'   │
│ 3. 记录 confirmed_by = "王工"       │
│ 4. 记录 confirmed_at = 当前时间     │
└─────────────────────────────────────┘
```

**数据库变化**：
| interface_id | display_status | status | confirmed_by |
|--------------|----------------|--------|--------------|
| S-XXX-01 | **已审查** | **confirmed** | 王工 |

---

## 五、第二批源文件进入时的流程（一周后）

### 场景：2025年12月8日（周一），用户再次运行程序

假设这一周发生了以下变化：
1. Excel 文件有更新（新增10行，删除5行）
2. 某些接口的"答复期限"变了
3. 设计人员填写了一些回文单号

```
用户点击"开始处理"
        ↓
┌─────────────────────────────────────┐
│  Step 1: Excel 筛选（main.py）      │
├─────────────────────────────────────┤
│ 本次筛选结果：310行                 │
│ （新增10行，删除5行，净增5行）      │
└─────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 2: Registry 查询（main.py 第1110-1172行）【关键步骤】 │
├─────────────────────────────────────────────────────────────┤
│ 当前代码逻辑：                                               │
│                                                             │
│ SQL查询：                                                   │
│ SELECT interface_id, project_id, display_status             │
│ FROM tasks                                                  │
│ WHERE file_type = 2                                         │
│   AND display_status IS NOT NULL  ← 【问题】太宽松          │
│   AND display_status != ''                                  │
│   AND status != 'confirmed'       ← 已确认的不加回          │
│   AND status != 'archived'        ← 已归档的不加回          │
│                                                             │
│ 【当前行为】：                                               │
│ 1. 建立整个Excel的索引（5000+行）                            │
│ 2. 对于数据库中的每个任务，在索引中查找匹配                  │
│ 3. 如果匹配到的行不在 final_rows 中，加入 pending_rows      │
│                                                             │
│ 【问题】：                                                   │
│ - 加回了不满足 process1 的行（其他科室）                     │
│ - 加回了不满足 process2 的行（2024年的旧接口）               │
│ - 导致 300行 → 600行                                        │
└─────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────┐
│  Step 3: Registry 写入             │
├─────────────────────────────────────┤
│ 对于 310 行 Excel 筛选结果：        │
│                                     │
│ ▼ 已存在的接口（280个）：           │
│   - 查询 business_id 找到旧任务     │
│   - 检查 interface_time 是否变化    │
│   - 变化：重置状态为 open/待完成    │
│   - 不变：继承旧状态                │
│                                     │
│ ▼ 新增的接口（30个）：              │
│   - 创建新任务                      │
│   - display_status = '待完成'       │
│   - first_seen_at = 2025-12-08      │
│                                     │
│ ▼ 消失的接口（20个）：              │
│   - 不会被删除，只是 last_seen_at   │
│     不再更新                        │
│   - 后续可通过 finalize_scan 归档   │
└─────────────────────────────────────┘
```

---

## 六、状态继承与重置的详细逻辑

### 6.1 什么时候继承状态？

```python
# service.py 第274-311行
if old_task and not need_reset:
    # 继承 display_status（如果当前是默认值'待完成'）
    if current_display_status == '待完成' and old_task['display_status'] != '待完成':
        fields['display_status'] = old_task['display_status']
    
    # 继承 status、completed_at、completed_by、confirmed_at、confirmed_by
    # 继承 assigned_by、assigned_at、responsible_person
```

**场景**：
- 设计人员上周填写了回文单号（display_status='待审查'）
- 本周 Excel 更新，该接口仍在筛选结果中
- interface_time 没有变化
- **结果**：继承 '待审查' 状态，不会变回 '待完成'

### 6.2 什么时候重置状态？

```python
# service.py 第69-130行 should_reset_task_status()
def should_reset_task_status(old_interface_time, new_interface_time, 
                             old_completed_val, new_completed_val):
    # 条件1: 接口时间变化
    if old_time != new_time:
        return True
    
    # 条件2: 完成列从有值变为空（任务被撤销）
    if old_comp and not new_comp:
        return True
    
    return False
```

**场景**：
- 任务 S-XXX-01 原答复期限 2025-03-15，状态='已完成'
- 本周 Excel 更新，答复期限改为 2025-04-15
- **结果**：状态被重置为 'open/待完成'，相当于新轮次任务

---

## 七、问题分析：为什么会出现"幻觉"

### 当前代码的问题

```python
# main.py 第1147-1169行
# 【问题1】索引建立在整个Excel上（5000+行），不仅是筛选通过的行
excel_index = {}
for idx in range(len(df)):  # ← 遍历全部行
    ...
    excel_index[key] = [idx]

# 【问题2】匹配时不验证是否通过筛选条件
for reg_interface_id, reg_project_id, reg_display_status in registry_tasks:
    key = (reg_interface_id, reg_project_id)
    if key in excel_index:
        matched_indices = excel_index[key]
        for idx in matched_indices:
            if idx not in final_rows:
                pending_rows.add(idx)  # ← 直接加入，不检查 process1
```

### 问题链条
```
1. 数据库中存在 2024年的旧任务（business_id 匹配）
        ↓
2. 该任务的 interface_id 在当前 Excel 中找到匹配行
        ↓
3. 该行不在 final_rows 中（因为日期是2024年，不满足 process2）
        ↓
4. 但代码直接把它加入 pending_rows
        ↓
5. 最终显示中出现了 2024年的"幻觉"数据
```

---

## 八、完整生命周期图

```
                          ┌──────────────────────────────────────┐
                          │          Excel 源文件                │
                          │  (每周更新，内容可能变化)             │
                          └──────────────────────────────────────┘
                                          │
                                          ▼
                          ┌──────────────────────────────────────┐
                          │      Step 1: Excel 筛选              │
                          │  process1: 科室筛选                  │
                          │  process2: 日期筛选                  │
                          │  process3: 排除条件                  │
                          │  process4: 空值检查                  │
                          │                                      │
                          │  输出: final_rows (300行)            │
                          └──────────────────────────────────────┘
                                          │
                                          ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          Step 2: Registry 查询与合并                            │
│                                                                                 │
│   ┌─────────────────────┐                    ┌─────────────────────┐           │
│   │   final_rows        │                    │   Registry 数据库   │           │
│   │   (300行)           │                    │   (历史任务)        │           │
│   └─────────────────────┘                    └─────────────────────┘           │
│              │                                          │                       │
│              │     ┌────────────────────────────────────┘                       │
│              │     │  查询: display_status IS NOT NULL                          │
│              │     │        AND status != 'confirmed'                           │
│              │     │        AND status != 'archived'                            │
│              ▼     ▼                                                            │
│         ┌─────────────────────────────────────┐                                 │
│         │            合并结果                 │                                 │
│         │  final_rows + pending_rows          │                                 │
│         │  (可能有问题: 加回了不该加的行)     │                                 │
│         └─────────────────────────────────────┘                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
                                          │
                                          ▼
                          ┌──────────────────────────────────────┐
                          │      Step 3: 角色筛选                │
                          │  设计人员: 只看责任人=自己           │
                          │  接口工程师: 看对应项目全部          │
                          │  所领导: 看全部                      │
                          │                                      │
                          │  输出: 显示数据 (150行)              │
                          └──────────────────────────────────────┘
                                          │
                                          ▼
                          ┌──────────────────────────────────────┐
                          │      Step 4: Registry 写入           │
                          │  【重要】写入的是角色筛选前的数据    │
                          │  即 final_rows (300行)               │
                          │                                      │
                          │  ▼ 已存在的任务: upsert，继承状态    │
                          │  ▼ 新任务: insert，设置初始状态      │
                          │  ▼ 消失的任务: 不处理，保留历史      │
                          └──────────────────────────────────────┘
                                          │
                                          ▼
                          ┌──────────────────────────────────────┐
                          │           用户操作                   │
                          │  ▼ 填写回文单号 → on_response_written│
                          │  ▼ 指派任务     → on_assigned        │
                          │  ▼ 确认任务     → on_confirmed       │
                          │  ▼ 忽略任务     → on_ignored         │
                          └──────────────────────────────────────┘
                                          │
                                          ▼
                            ┌────────────────────────┐
                            │    下一次扫描循环      │
                            │    (回到 Step 1)       │
                            └────────────────────────┘
```

---

## 九、状态流转图

```
                    ┌─────────────────┐
                    │    新任务进入   │
                    └────────┬────────┘
                             │
                             ▼
    ┌───────────────────────────────────────────────────────┐
    │ 有责任人？                                            │
    │ ├─ 是 → display_status = '待完成'                     │
    │ └─ 否 → display_status = '请指派'                     │
    │                                                       │
    │ status = 'open'                                       │
    └───────────────────────────────────────────────────────┘
                             │
            ┌────────────────┼────────────────┐
            │                │                │
            ▼                ▼                ▼
    ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
    │  上级指派    │ │ 设计人员填写 │ │  任务消失    │
    │  任务        │ │ 回文单号     │ │  (Excel中    │
    └──────┬───────┘ └──────┬───────┘ │   不再出现)  │
           │                │         └──────┬───────┘
           ▼                ▼                │
    ┌──────────────┐ ┌──────────────┐        │
    │display_status│ │ 有指派人？   │        │
    │= '待完成'    │ │ ├─是→'待指派│        │
    │              │ │ │    人审查' │        │
    │responsible   │ │ └─否→'待审查'│        │
    │_person=XX    │ │              │        │
    │assigned_by=YY│ │status=       │        │
    └──────┬───────┘ │'completed'   │        │
           │         └──────┬───────┘        │
           │                │                │
           │                ▼                │
           │         ┌──────────────┐        │
           │         │  上级确认    │        │
           │         │  (勾选)      │        │
           │         └──────┬───────┘        │
           │                │                │
           │                ▼                │
           │         ┌──────────────┐        │
           │         │display_status│        │
           │         │= '已审查'    │        │
           │         │status=       │        │
           │         │'confirmed'   │        │
           │         └──────────────┘        │
           │                                 │
           └─────────────────────────────────┤
                                             │
                                             ▼
                                    ┌──────────────┐
                                    │  任务归档    │
                                    │  (7天后)     │
                                    │status=       │
                                    │'archived'    │
                                    └──────────────┘
```

---

## 十、Registry 查询加回的设计意图

### 原始设计目的

Registry 查询的目的是**防止任务"消失"**：

1. **场景A**：设计人员填写了回文单号（status='completed'），等待上级确认
   - 如果下次扫描时该行刚好不满足某个筛选条件
   - 任务会"消失"，上级无法确认
   - **解决**：从 Registry 中加回这个任务

2. **场景B**：上级已指派任务给某人
   - 被指派人需要看到这个任务
   - 如果任务"消失"，被指派人找不到它
   - **解决**：从 Registry 中加回这个任务

### 当前实现的问题

```sql
-- 当前查询太宽松
WHERE display_status IS NOT NULL
  AND display_status != ''
```

这会返回：
- ✅ '待审查' - 应该加回
- ✅ '待指派人审查' - 应该加回
- ❓ '待完成' - 是否需要加回？
- ❓ '请指派' - 是否需要加回？

### 建议的修复方案

根据实际需求选择：

**方案A**：只加回"待审查"状态（最严格）
```sql
WHERE display_status IN ('待审查', '待指派人审查')
  AND status = 'completed'
```

**方案B**：加回所有有状态的任务，但验证筛选条件
```python
for idx in matched_indices:
    if idx not in process1_rows:  # 必须通过科室筛选
        continue
    if idx not in final_rows:
        pending_rows.add(idx)
```

---

## 十一、总结

| 阶段 | 数据范围 | 说明 |
|------|----------|------|
| Excel 筛选后 | 300行 | 满足 process1-4 的行 |
| Registry 查询后 | 300+N行 | 加回了 N 个"待审查"任务 |
| 角色筛选后 | 150行 | 用户实际看到的数据 |
| Registry 写入 | 300行 | 写入的是筛选后、角色筛选前的数据 |

**关键点**：
1. Registry 写入的是**Excel 筛选后**的数据，不是显示的数据
2. Registry 查询加回的任务可能**绕过 Excel 筛选条件**
3. 这是导致"幻觉"问题的根本原因

---

## 九、维护模式（协作式释放锁）

### 9.1 触发方式
- 管理员在设置中点击“进入维护模式（释放占用）”，创建维护标志文件
- 维护标志路径：`<data_folder>/.registry/maintenance.lock`
- 退出维护模式：删除该标志文件

### 9.2 客户端行为
- 已更新客户端在访问 `registry.db` 前检测维护标志
- 检测到维护模式后：关闭连接、弹窗提示，并退出程序以释放占用
- 读写完成后立即关闭连接，减少共享锁持有时间

### 9.3 风险与限制
- 协作式释放：无法强制踢掉远端进程
- **仅对更新版本有效**：旧版本客户端需要手动退出