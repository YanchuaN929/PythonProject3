# 已确认任务重新打开逻辑修复报告（2025-11-08）

## 🎯 问题发现

用户发现了我之前修复中的一个严重逻辑错误：

**实际业务场景**：
1. 接口完成并被上级确认（状态=已确认）
2. 过了一段时间，接口又被重新打开（需要重新处理）
3. 体现在Excel源文件上：
   - **完成时间列（M/N/Q/T/V/J列）数据被清零**
   - **预期时间列（接口时间）可能会变化**

**预期行为**：
- 任务应该重置为"待完成"或"请指派"
- 清除completed_at、confirmed_at、confirmed_by
- 重新出现在主窗口，可以重新处理

**我之前的错误逻辑**：
- 已确认的任务永久保持确认状态
- 即使完成列被清空也不会重置
- 导致任务无法重新进入工作流

---

## 🐛 问题根源

### 根源1：逻辑顺序错误

**错误代码**（registry/service.py 第619-630行）：
```python
# ❌ 错误：首先检查是否已确认
if old_task['status'] == Status.CONFIRMED and old_task['confirmed_at']:
    # 保持确认状态（即使完成列被清空）
    fields['status'] = Status.CONFIRMED
    ...
else:
    # 然后才检查完成列是否被清空
    if not new_completed_val and old_task['completed_at']:
        # 重置
        ...
```

**问题**：
- 已确认的任务会跳过完成列检查
- 完成列被清空时不会重置
- 违反业务逻辑

---

### 根源2：ON CONFLICT逻辑使用COALESCE

**错误代码**（registry/service.py 第719-721行）：
```python
ON CONFLICT(id) DO UPDATE SET
    confirmed_by = COALESCE(excluded.confirmed_by, confirmed_by),
    completed_at = COALESCE(excluded.completed_at, completed_at),
    confirmed_at = COALESCE(excluded.confirmed_at, confirmed_at)
```

**问题**：
- `COALESCE(NULL, old_value)` = `old_value`
- 即使我们设置`fields['confirmed_at'] = None`（重置）
- ON CONFLICT时仍会保留旧值
- 无法真正清除这些字段

---

## ✅ 修复方案

### 修复1：调整逻辑优先级

**新逻辑顺序**（registry/service.py 第617-679行）：

```python
if old_task:
    new_completed_val = fields.get('_completed_col_value', '')
    old_completed_val = '有值' if old_task['completed_at'] else ''
    
    # ✅ 优先级1：检查完成列是否被清空（最高优先级）
    if not new_completed_val and old_task['completed_at']:
        # 完成列被删除，强制重置（包括已确认的任务）
        print(f"[Registry] 接口{key['interface_id']}: 完成列被清空，重置状态")
        fields['display_status'] = '待完成' if old_task['responsible_person'] else '请指派'
        fields['status'] = Status.OPEN
        # ✅ 清除完成相关字段
        fields['completed_at'] = None
        fields['confirmed_at'] = None
        fields['confirmed_by'] = None
        # 保留指派信息
        ...
    
    # ✅ 优先级2：如果已确认且完成列仍有值，保持确认状态
    elif old_task['status'] == Status.CONFIRMED and old_task['confirmed_at'] and new_completed_val:
        # 已确认且完成列未被清空，保持确认状态
        print(f"[Registry] 接口{key['interface_id']}: 已确认且完成列有值，保持确认状态")
        fields['status'] = Status.CONFIRMED
        fields['display_status'] = None
        fields['confirmed_at'] = old_task['confirmed_at']
        fields['confirmed_by'] = old_task['confirmed_by']
        fields['completed_at'] = old_task['completed_at']
        ...
    
    # ✅ 优先级3：检查接口时间变化
    elif should_reset_task_status(...):
        # 时间列变化，重置
        ...
    
    # ✅ 优先级4：其他情况，继承状态
    else:
        # 继承状态
        ...
```

**关键改进**：
1. ✅ **完成列检查优先于确认状态检查**
2. ✅ 只有当`new_completed_val`有值且已确认时，才保持确认状态
3. ✅ 完成列被清空时，强制重置（包括已确认任务）
4. ✅ 显式设置confirmed字段为None

---

### 修复2：强制更新ON CONFLICT字段

**新逻辑**（registry/service.py 第706-722行）：

```python
ON CONFLICT(id) DO UPDATE SET
    business_id = excluded.business_id,
    department = excluded.department,
    interface_time = excluded.interface_time,
    role = excluded.role,
    status = excluded.status,              # ✅ 强制更新（支持重置）
    display_status = excluded.display_status,  # ✅ 强制更新（支持重置）
    last_seen_at = excluded.last_seen_at,
    assigned_by = COALESCE(excluded.assigned_by, assigned_by),
    assigned_at = COALESCE(excluded.assigned_at, assigned_at),
    responsible_person = CASE
        WHEN assigned_by IS NOT NULL THEN responsible_person
        ELSE COALESCE(excluded.responsible_person, responsible_person)
    END,
    confirmed_by = excluded.confirmed_by,    # ✅ 强制更新（支持重置为NULL）
    completed_at = excluded.completed_at,    # ✅ 强制更新（支持重置为NULL）
    confirmed_at = excluded.confirmed_at     # ✅ 强制更新（支持重置为NULL）
```

**关键改进**：
1. ✅ 移除COALESCE，直接使用excluded值
2. ✅ 当excluded值为NULL时，会覆盖旧值为NULL
3. ✅ 支持重置confirmed字段

---

## 🔄 完整的状态流转逻辑

### 场景1：正常完成→确认→重新打开

```
时刻T1: 接口首次出现
  └─ status=open, display_status='待完成'

时刻T2: 设计人员写入回文单号
  └─ 完成列填充
  └─ status=completed, display_status='待审查'
  └─ completed_at='2025-11-08 10:00'

时刻T3: 上级确认
  └─ status=confirmed, display_status=NULL
  └─ confirmed_at='2025-11-08 11:00'
  └─ confirmed_by='王五'

时刻T4: 接口重新打开（完成列被清空）
  ✅ 检测：new_completed_val=空, old_completed_val='有值'
  ✅ 触发：完成列被清空，强制重置
  └─ status=open, display_status='待完成'
  └─ completed_at=NULL
  └─ confirmed_at=NULL
  └─ confirmed_by=NULL
  └─ 重新出现在主窗口

时刻T5: 设计人员再次填写回文单号
  └─ status=completed, display_status='待审查'
  └─ completed_at='2025-11-08 15:00'（新时间）
```

---

### 场景2：已确认任务，完成列仍有值

```
时刻T1: 任务已确认
  └─ status=confirmed, completed_at='2025-11-08 10:00'
  └─ confirmed_at='2025-11-08 11:00', confirmed_by='王五'

时刻T2: 再次处理（完成列仍有值）
  ✅ 检测：new_completed_val='有值', old_status=confirmed
  ✅ 触发：已确认且完成列有值，保持确认状态
  └─ status=confirmed, display_status=NULL
  └─ confirmed_at='2025-11-08 11:00', confirmed_by='王五'（保留）
  └─ 不出现在主窗口
```

---

### 场景3：接口时间变化触发重置

```
时刻T1: 任务已确认
  └─ interface_time='2025-10-01'

时刻T2: 接口时间变化
  └─ interface_time='2025-11-01'（新值）
  ✅ 检测：接口时间变化
  ✅ 触发：重置状态
  └─ status=open, display_status='待完成'
  └─ 重新进入工作流
```

---

## 📊 修复统计

| 修复项 | 文件 | 修改位置 | 修改行数 |
|--------|------|---------|----------|
| 调整逻辑优先级 | registry/service.py | 第617-679行 | 修改63行 |
| 强制更新ON CONFLICT | registry/service.py | 第706-722行 | 修改17行 |
| **总计** | **1个文件** | - | **约80行** |

---

## 🧪 测试验证

### 测试1：已确认任务重新打开

**步骤**：
1. 确认一个任务（上级勾选"已完成"）
2. 在源Excel中清空该接口的完成列
3. 点击"开始处理"

**预期结果**：
- ✅ 控制台输出："完成列被清空，重置状态（old_status=confirmed）"
- ✅ 任务重新出现在主窗口
- ✅ 状态显示"📌 待完成"或"❗ 请指派"
- ✅ 历史查询显示最新状态为"待完成"（不是"已确认"）

---

### 测试2：已确认任务保持确认

**步骤**：
1. 确认一个任务
2. 源Excel中完成列仍有值
3. 点击"开始处理"

**预期结果**：
- ✅ 控制台输出："已确认且完成列有值，保持确认状态"
- ✅ 任务不出现在主窗口
- ✅ 历史查询显示状态仍为"已确认"
- ✅ 确认人和确认时间未变

---

### 测试3：完成列被清空后再次填写

**步骤**：
1. 确认一个任务
2. 清空完成列（重新打开）
3. 点击"开始处理"（任务重置）
4. 设计人员再次填写回文单号
5. 查看历史记录

**预期结果**：
- ✅ 历史记录显示两条记录：
  - 旧记录：状态=已确认，上级人员=王五，确认时间=旧时间
  - 新记录：状态=待审查，完成时间=新时间

---

## 📝 逻辑优先级总结

### 修复后的完整优先级

1. **优先级1（最高）**：完成列被清空
   - 条件：`not new_completed_val and old_completed_val`
   - 动作：强制重置（包括已确认任务）
   - 清除：completed_at, confirmed_at, confirmed_by

2. **优先级2**：已确认且完成列仍有值
   - 条件：`status=CONFIRMED and confirmed_at and new_completed_val`
   - 动作：保持确认状态
   - 保留：confirmed_at, confirmed_by, completed_at

3. **优先级3**：接口时间变化
   - 条件：`should_reset_task_status()`
   - 动作：重置状态

4. **优先级4（最低）**：其他情况
   - 动作：继承旧状态

---

## ✅ 总结

### 修复前的问题

1. ❌ 已确认任务即使完成列被清空也不会重置
2. ❌ 无法重新进入工作流
3. ❌ ON CONFLICT的COALESCE阻止字段清空

### 修复后的效果

1. ✅ 完成列被清空时强制重置（包括已确认任务）
2. ✅ 已确认任务可以重新打开
3. ✅ 清除confirmed字段，重新进入工作流
4. ✅ 只有完成列仍有值时才保持确认状态
5. ✅ 符合实际业务场景

---

## 🎯 业务逻辑准确性

**现在的逻辑完全符合您描述的业务场景**：

1. ✅ 已确认的任务可以重新打开
2. ✅ 完成时间列清零 → 任务重置
3. ✅ 预期时间列变化 → 任务重置（如果有完成时间变化）
4. ✅ 重置后任务重新进入工作流
5. ✅ 历史记录完整保留所有状态变化

---

**修复完成时间**：2025-11-08  
**Token使用**：约12.3万/100万（12.3%）  
**状态**：✅ 逻辑错误已修复  
**无linter错误**：✅ 通过检查

---

## 📖 附录：完成列定义

### 6种文件类型的完成列

| 文件类型 | 完成列 | 说明 |
|---------|--------|------|
| 文件1（内部需打开接口） | M列 | 回文单号 |
| 文件2（内部需回复接口） | N列 | 回文单号 |
| 文件3（外部需打开接口） | Q列 | 回文单号 |
| 文件4（外部需回复接口） | T列 | 回复日期 |
| 文件5（三维提资接口） | V列 | 提交日期 |
| 文件6（收发文函） | J列 | 回复日期 |

**预期时间列**：接口时间（所有文件类型共用）

---

**感谢您发现这个逻辑错误！现在程序完全符合实际业务需求。** 🎉

