# 写入任务改造方案

## 设计原则
1. **保持原有架构风格**：`ExcelProcessorApp` 负责流程、`WindowManager` 负责 UI、业务逻辑分散在独立模块；新增代码沿用该模式，避免巨型文件。
2. **模块化拆分**：新功能尽量放在独立文件（例如 `write_queue.py`、`task_cache.py`、`task_panel.py`），并通过清晰的接口与现有逻辑解耦。
3. **阶段式交付+测试驱动**：每个阶段完成后都要配套 pytest（单元和集成），确保改动可回归。
4. **UI 流畅优先**：所有前台操作立即返回，由后台异步写入；界面通过缓存及时反映结果。
5. **安全可靠**：写队列必须防止公共盘 registry 长时间占用；检测读写冲突，避免用户读取到旧数据。

## 阶段划分

### 阶段一：写入队列与缓存基础
**目标**：实现稳定的写队列、任务缓存、以及现有写入点的改造。

1. **写队列模块**
   - 新增 `write_queue/task_queue.py`，在单线程后台顺序执行写任务；支持 Excel 写入和 Registry 钩子。
   - 任务字段：`id`、`type`、`file_path`、`row_index`、`payload`、`submitted_by`、`submitted_at`、`status`、`error`.
   - 提供提交接口与状态监听（回调或事件）。

2. **任务提交点改造**
   - `distribution.py`：指派成功后生成按文件分组的任务提交到队列，不再直接调用 `openpyxl.save`。
   - `input_handler.py`：回文单号写入改为任务提交；即使任务失败也能返回详细错误。
   - 其他写操作（忽略延期、手动标记等）如存在写 Excel/Registry 的逻辑，也统一封装为任务。

3. **任务缓存**
   - 新建 `task_cache.py`：使用 `result_cache/write_tasks.jsonl` 或轻量 sqlite 记录所有任务及状态，支持重启恢复。
   - 写队列在任务状态变化时更新缓存；UI 只读该缓存即可展示任务列表。

4. **阶段性测试**
   - 针对写队列：提交/执行顺序、失败重试、缓存落盘等单元测试。
   - 针对指派/回文改造：mock 队列确保提交成功、旧逻辑移除。

### 阶段二：读写冲突防护 + 临时 UI 缓存
**目标**：在保持 UI 流畅同时，保证读操作不会与后台写冲突。

1. **读操作前检查**
   - `start_processing` 入口统一检查写队列是否为空。
   - 手动模式：若有排队任务，弹窗提示并阻止处理。
   - 自动模式：若队列非空，进入后台等待模式，每 20 秒重试一次，直到队列清空或达到超时时间。

2. **临时 UI 缓存**
   - 新建 `ui_pending_cache.py`：存储尚未落盘但用户已提交的指派/回文/上级勾选等结果，并记录适用角色。
   - 主列表、指派窗口在渲染时对结果进行覆盖，使用户立即看到变化；并提供针对 Treeview 的“定位并删除/更新”方法。
   - 当队列任务执行完成后，移除相应缓存条目；若任务失败，则撤回缓存并提醒用户（在面板与弹窗中提示，可重新提交）。

3. **阶段性测试**
   - 测试读操作在队列非空时的阻断与提示（手动/自动模式）。
   - 测试临时缓存对 Treeview/指派窗口的覆盖逻辑。

### 阶段三：写入任务记录窗与 UI 调整
**目标**：让用户清晰看到后台队列状态，并只关注自己的任务。

1. **布局调整**
   - 压缩“Excel 文件信息”区域，与旁侧新增 `TaskRecordPanel`（独立模块 `task_panel.py`）。
   - 任务窗字段：提交时间、用户、任务类型、目标文件、状态、错误信息。
   - 添加“只看我的任务”复选框 / 搜索框。

2. **数据驱动**
   - `TaskRecordPanel` 读取 `task_cache` 及后台队列事件，启动后即显示最近任务，并在状态变化时即时刷新。
   - 任务面板需显示失败原因，并支持按提交人过滤；若失败则引导用户重新提交或联系管理员。

3. **阶段性测试**
   - UI 层可通过组件级别测试（mock WindowManager）验证是否正确渲染任务记录、过滤逻辑。

### 阶段四：完善、优化与文档
1. **健壮性与并发**
   - 确保写队列与 Registry 同步线程互不阻塞；对公共盘的写操作保持短连接并加入重试。
   - 处理任务失败时的重试/人工介入机制（例如在任务窗提供“重新执行”按钮）。

2. **综合测试**
   - 多用户模拟：命令级集成测试（pytest + monkeypatch）验证并发提交时：队列顺序、缓存刷新、读写阻断逻辑。
   - 自动模式流程：模拟定时任务，验证队列阻塞时自动等待并能恢复。

3. **文档与培训**
   - 更新 `document/` 下的使用说明，描述写入任务记录窗、临时缓存、自动等待等操作提示。
   - 在 UI 上加入悬浮提示/帮助按钮，解释“只看我的任务”等功能。

## 漏洞检查与补充
1. **任务丢失风险**：缓存文件损坏或程序异常退出。  
   → 采用 append-only JSONL + 启动时校验/修复机制；必要时定期备份。

2. **队列线程异常**：写线程崩溃导致任务堆积。  
   → 主程序需监控线程状态，若线程意外退出，立即重启并在任务窗提示。

3. **Registry 长时间锁占用**：若公共盘写入失败一直重试可能阻塞。  
   → 设置指数退避 + 最大重试次数，并在任务窗标记失败，等待人工处理。

4. **UI 缓存与真实数据不一致**：若任务最终失败，但 UI 仍显示已更新。  
   → 当任务失败时，立即撤回对应缓存条目，提示用户（面板 + 弹窗），并提供“重新提交”入口。

5. **自动模式长时间等待**：若写队列一直有任务，自动模式持续阻塞。  
   → 增加最大等待时间（例如 5 分钟），超时后写日志并跳过本次自动运行，防止无限等待。

6. **多模块协作复杂度**：为防止文件过长，所有新模块需写清楚 API 接口文档，核心类/函数需简洁注释。

---

> 实施顺序：按阶段推进，每阶段交付代码、对应 pytest、以及对文档/帮助的更新。阶段一完成后可先合入（保证写队列稳定）；后续阶段逐步上线 UI 和防护策略。
