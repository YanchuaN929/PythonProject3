# 责任人列位置对比验证

## 目的
验证责任人的**读取位置**（main.py）和**写入位置**（distribution.py）是否一致，确保逻辑闭环。

---

## 对比表

### 责任人列

| 文件类型 | 读取位置（main.py已实现） | 写入位置（distribution.py需实现） | Excel列名 | 索引 | 是否一致 |
|---------|------------------------|--------------------------------|----------|------|---------|
| **文件1** | `df.iloc[idx, 17]` | R列 | R | 17 | ✅ 一致 |
| **文件2** | `df.iloc[idx, 38]` | AM列 | AM | 38 | ✅ 一致 |
| **文件3** | `df.iloc[idx, 41]` | AP列 | AP | 41 | ✅ 一致 |
| **文件4** | `df.iloc[idx, 33]` | AH列 | AH | 33 | ✅ 一致 |
| **文件5** | `df.iloc[idx, 10]` | K列 | K | 10 | ✅ 一致 |
| **文件6** | `df.iloc[idx, 23]` | X列 | X | 23 | ✅ 一致 |

### 签名列（回文单号输入时记录的用户姓名）

| 文件类型 | 签名列位置（input_handler.py） | Excel列名 | 索引 | 说明 |
|---------|------------------------------|----------|------|------|
| **文件1** | V列 | V | 21 | 设计人回写回文单号时的签名 |
| **文件2** | AL列 | AL | 37 | 设计人回写回文单号时的签名 |
| **文件3** | BM列 | BM | 64 | 设计人回写回文单号时的签名 |
| **文件4** | AT列 | AT | 45 | 设计人回写回文单号时的签名 |
| **文件5** | W列 | W | 22 | 设计人回写回文单号时的签名 |
| **文件6** | N列 | N | 13 | 设计人回写回文单号时的签名 |

---

## 代码验证

### 文件1 - R列（索引17）

**读取**（main.py 第454-465行）：
```python
# 新增"责任人"列（基于R列：索引17，提取中文）
try:
    zh_pattern = re.compile(r"[\u4e00-\u9fa5]+")
    owners = []
    for idx in result_df.index:
        cell_val = df.iloc[idx, 17] if 17 < len(df.columns) else None
        s = str(cell_val) if cell_val is not None else ""
        found = zh_pattern.findall(s)
        owners.append("".join(found))
    result_df['责任人'] = owners
```

**写入**（distribution.py需实现）：
```python
# 伪代码
wb = load_workbook(file_path)
ws = wb.active
ws[f"R{row_index}"] = assigned_name  # R列
wb.save(file_path)
```

---

### 文件2 - AM列（索引38）

**读取**（main.py 第1050-1064行）：
```python
# 新增"责任人"列（基于AM列：索引38，提取中文）
try:
    zh_pattern = re.compile(r"[\u4e00-\u9fa5]+")
    owners = []
    for idx in result_df.index:
        cell_val = df.iloc[idx, 38] if 38 < len(df.columns) else None
        s = str(cell_val) if cell_val is not None else ""
        found = zh_pattern.findall(s)
        owner_str = "".join(found)
        # 空值显示"无"
        owners.append(owner_str if owner_str else "无")
    result_df['责任人'] = owners
except Exception:
    result_df['责任人'] = "无"
```

**写入**（distribution.py需实现）：
```python
# AM列 = 第39列
ws[f"AM{row_index}"] = assigned_name
```

---

### 文件3 - AP列（索引41）

**读取**（main.py 第1512-1523行）：
```python
# 新增"责任人"列（基于AP列：索引41，提取中文）
try:
    zh_pattern = re.compile(r"[\u4e00-\u9fa5]+")
    owners = []
    for idx in result_df.index:
        cell_val = df.iloc[idx, 41] if 41 < len(df.columns) else None
        s = str(cell_val) if cell_val is not None else ""
        found = zh_pattern.findall(s)
        owners.append("".join(found))
    result_df['责任人'] = owners
```

**写入**（distribution.py需实现）：
```python
# AP列 = 第42列（索引从0开始）
# 但Excel列名是AP
from openpyxl.utils import get_column_letter
col_letter = 'AP'  # 或 get_column_letter(42)
ws[f"{col_letter}{row_index}"] = assigned_name
```

---

### 文件4 - AH列（索引33）

**读取**（main.py 第2275-2286行）：
```python
# 新增"责任人"列（基于AH列：索引33，提取中文）
try:
    zh_pattern = re.compile(r"[\u4e00-\u9fa5]+")
    owners = []
    for idx in result_df.index:
        cell_val = df.iloc[idx, 33] if 33 < len(df.columns) else None
        s = str(cell_val) if cell_val is not None else ""
        found = zh_pattern.findall(s)
        owners.append("".join(found))
    result_df['责任人'] = owners
```

**写入**（distribution.py需实现）：
```python
ws[f"AH{row_index}"] = assigned_name
```

---

### 文件5 - K列（索引10）

**读取**（main.py 第2866-2877行）：
```python
# 新增"责任人"列（基于K列：索引10，提取中文）
try:
    zh_pattern = re.compile(r"[\u4e00-\u9fa5]+")
    owners = []
    for idx in result_df.index:
        cell_val = df.iloc[idx, 10] if 10 < len(df.columns) else None
        s = str(cell_val) if cell_val is not None else ""
        found = zh_pattern.findall(s)
        owners.append("".join(found))
    result_df['责任人'] = owners
```

**写入**（distribution.py需实现）：
```python
ws[f"K{row_index}"] = assigned_name
```

---

### 文件6 - X列（索引23）

**读取**（main.py 第3292-3313行）：
```python
# 责任人：X列（索引23）按分隔符拆分并保留原始姓名集合（供过滤）
try:
    owners = []
    for idx in result_df.index:
        cell_val = df.iloc[idx, 23] if 23 < len(df.columns) else None
        s = str(cell_val) if cell_val is not None else ""
        
        # 分隔符：逗号、分号、空格等
        tokens = []
        for sep in [',', '，', ';', '；', ' ']:
            if sep in s:
                tokens = [t.strip() for t in s.split(sep) if t.strip()]
                break
        if not tokens and s.strip():
            tokens = [s.strip()]
        
        names_str = ','.join(tokens)
        
        # 【新增】过滤责任人：只保留在姓名角色表中存在的姓名
        if valid_names_set:
            names_str = filter_valid_names(names_str, valid_names_set)
        
        owners.append(names_str)
    result_df['责任人'] = owners
```

**写入**（distribution.py需实现）：
```python
# 注意：文件6支持多人，需要追加而非覆盖
# 或者：直接覆盖，用逗号分隔多人
ws[f"X{row_index}"] = assigned_name  # 如果是单人指派
# 或
existing = ws[f"X{row_index}"].value or ""
new_value = f"{existing},{assigned_name}" if existing else assigned_name
ws[f"X{row_index}"] = new_value  # 如果支持多人追加
```

---

## Excel列名与索引对照

### 责任人列

| 列名 | 索引 | 说明 |
|------|------|------|
| K | 10 | 文件5责任人 |
| R | 17 | 文件1责任人 |
| X | 23 | 文件6责任人（多人） |
| AH | 33 | 文件4责任人 |
| AM | 38 | **文件2责任人** |
| AP | 41 | 文件3责任人 |

### 签名列（回文单号输入时）

| 列名 | 索引 | 说明 |
|------|------|------|
| N | 13 | 文件6签名 |
| V | 21 | 文件1签名 |
| W | 22 | 文件5签名 |
| AL | 37 | 文件2签名 |
| AT | 45 | 文件4签名 |
| BM | 64 | 文件3签名 |

**索引说明**：Pandas的`iloc[idx, col_index]`中，col_index是从0开始的索引。
**Excel列名**：openpyxl中使用列名，如`ws['R2']`、`ws['AP5']`、`ws['AM3']`。

---

## 逻辑闭环验证

### 流程验证

```
1. 用户筛选数据
   ↓
2. main.py读取责任人（R/AP/AH/K/X列）
   ↓
3. 显示在GUI的"责任人"列
   ↓
4. 用户发现责任人为空
   ↓
5. 打开任务指派界面（distribution.py）
   ↓
6. 选择责任人并确认
   ↓
7. distribution.py写入Excel（R/AP/AH/K/X列）
   ↓
8. 下次筛选时，main.py重新读取
   ↓
9. 显示新指派的责任人 ✅ 闭环完成
```

### 文件2的逻辑闭环

```
1. 用户筛选数据
   ↓
2. main.py读取AM列责任人（空值显示"无"）
   ↓
3. 显示在GUI的"责任人"列
   ↓
4. 用户发现责任人为空
   ↓
5. 打开任务指派界面（distribution.py）
   ↓
6. 选择责任人并确认
   ↓
7. distribution.py写入Excel的AM列
   ↓
8. 下次筛选时，main.py重新读取AM列
   ↓
9. 显示新指派的责任人 ✅ 闭环完成
```

---

## 实现函数设计

### distribution.py需要实现的函数

```python
def get_responsible_column(file_type):
    """
    获取各文件类型的责任人列名
    
    参数:
        file_type: 文件类型(1-6)
    
    返回:
        str: Excel列名，如'R'、'AP'、'AM'等
    """
    column_map = {
        1: 'R',   # 索引17
        2: 'AM',  # 索引38
        3: 'AP',  # 索引41
        4: 'AH',  # 索引33
        5: 'K',   # 索引10
        6: 'X',   # 索引23
    }
    return column_map.get(file_type)


def save_assignment(file_type, file_path, row_index, assigned_name, 
                    project_id, interface_id, file_manager):
    """
    保存指派结果
    
    参数:
        file_type: 文件类型(1-6)
        file_path: Excel文件路径
        row_index: Excel行号
        assigned_name: 指派的责任人姓名
        project_id: 项目号
        interface_id: 接口号
        file_manager: FileIdentityManager实例
    
    返回:
        bool: 成功返回True
    """
    # 所有文件（包括文件2）：写入Excel责任人列
    try:
        from openpyxl import load_workbook
        
        # 获取责任人列名
        col_name = get_responsible_column(file_type)
        if not col_name:
            return False
        
        # 打开Excel
        wb = load_workbook(file_path)
        ws = wb.active
        
        # 写入责任人
        ws[f"{col_name}{row_index}"] = assigned_name
        
        # 保存
        wb.save(file_path)
        wb.close()
        
        print(f"成功指派: {file_path}, 行{row_index}, 责任人={assigned_name}")
        return True
        
    except Exception as e:
        print(f"指派失败: {e}")
        return False
```

---

## 结论

✅ **所有文件的读取列和写入列完全一致**  
✅ **文件2的特殊处理逻辑正确**  
✅ **逻辑闭环完整，可以开始实现阶段3**

---

**验证日期**: 2025-10-30  
**验证工程师**: AI Assistant

